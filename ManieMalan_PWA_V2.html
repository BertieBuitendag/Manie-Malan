<!DOCTYPE html>
<!--
================================================================================
THE LOGICAL ADVENTURES OF CLEVER MANIE MALAN THE CODING MOUSE
MAJOR VERSION 2.0
================================================================================

GAME INFORMATION:
- Title: The Logical Adventures of Clever Manie Malan the Coding Mouse
- Version: Major Version 2.0
- Date: February 2026
- Target Audience: Grade 4-5 learners (ages 9-12)
- Languages: English and Afrikaans

DESCRIPTION:
An educational block-based programming game that teaches sequential programming
concepts, logical thinking, and problem-solving through grid navigation challenges.
Players guide Manie the mouse to collect cheese by building a command sequence
before executing it - mirroring how real programmers write code before running it.

KEY FEATURES:
- 5 random difficulty levels (3x4 to 6x9 grids) with BFS-validated solvability
- Level Book mode: 15 handcrafted challenge levels on a fixed 5x5 grid
- Multiple obstacle types (traps, walls, cats) with unique behaviours
- Command queue with repeat functionality (1-9 repeats per command)
- Bilingual support (English / Afrikaans) switchable at any time
- Animated SVG characters with flowing capes, tail wiggle and smooth transitions
- Keyboard shortcuts for advanced users
- Hint toggle switch showing L/R labels for directional orientation
- Auto-reset functionality for educational scaffolding
- Grid screenshot export (right-click grid) for paper-based exercises
- Developer level-skip cheat (double-click level indicator) for testing

GAME MECHANICS:
- Mouse can turn left/right, move forward, jump (2 cells), and eat cheese
- Jump LEAPS OVER traps - landing on trap still triggers game over
- Jump is BLOCKED by walls at intermediate or landing cell
- Jump at grid boundary silently skips (does not stop execution)
- Cat danger zones (9 cells around cat) trigger animated attacks
- Only the NEAREST cat attacks when mouse enters a danger zone
- Traps cause instant game over with auto-reset
- Win condition: Collect ALL cheese pieces using the Eat command

LEVEL BOOK - 15 CHALLENGES:
- Levels 1-5:  Original challenges (walking + basic jumps)
- Levels 6-10: Intermediate (multiple cats, more traps, tighter mazes)
- Levels 11-15: Expert (complex layouts, perimeter puzzles, pure wall mazes)
- Level 7 has a forced initial direction (UP) to enable its specific solution path
- All 15 levels verified solvable through manual path analysis

EDUCATIONAL OBJECTIVES:
- Introduction to sequential programming
- Understanding of loops and repetition
- Spatial reasoning and grid navigation
- Problem decomposition and algorithmic thinking
- Learning that jump can be used strategically to bypass obstacles

TECHNICAL DETAILS:
- Single-file HTML/CSS/JavaScript application
- One external dependency: html2canvas (CDN) for grid screenshot export
- Works offline (except screenshot feature requires CDN load)
- File: ManieMalan_PWA_V2.html

DEVELOPER: Bertie (TUT Senior Lecturer)
INSTITUTION: Tshwane University of Technology (TUT)
DEPARTMENT: Information Technology
PURPOSE: Teaching computer science and programming concepts

Full documentation available at the end of this file.
================================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <script>
        if('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');
        // Lock to landscape on mobile
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(() => {});
        }
    </script>
    <title>The Logical Adventures of Clever Manie Malan the Coding Mouse</title>
    <!-- No external dependencies - screenshot uses native Canvas API -->
    <!-- ========================================
         CSS STYLES - All game styling
         ======================================== -->
    <style>
        /* ===== BODY AND LAYOUT ===== */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #006400 0%, #228B22 50%, #FFD700 100%);
        }

        /* Splash Screen Styles */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #006400 0%, #228B22 50%, #FFD700 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s ease-out;
            overflow: hidden;
            padding: 0;
        }

        #splashScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .splash-container {
            background: white;
            border-radius: 20px;
            padding: 20px 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-width: 1100px; /* Wider for landscape */
            margin: auto;
        }
        
        /* Title frame with cats */
        .splash-title-frame {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            background: rgba(255, 215, 0, 0.08);
            border: 2px solid #FFD700;
            border-radius: 12px;
            padding: 12px 20px;
            margin-bottom: 15px;
        }

        .splash-title {
            flex: 1;
        }

        .splash-title-line1 {
            color: #006400;
            font-size: 18px;
            margin-bottom: 3px;
        }

        .splash-title-main {
            color: #FFD700;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
            margin: 5px 0;
        }

        .splash-title-line3 {
            color: #006400;
            font-size: 18px;
            margin-top: 3px;
        }

        .splash-character-container {
            margin: 15px 0; /* Reduced from 30px */
            position: relative;
        }

        #splashMouse {
            transition: transform 0.2s ease;
        }

        #splashMouse:hover {
            transform: scale(1.05);
        }

        #splashMouse:active {
            transform: scale(0.98);
        }

        .splash-language-prompt {
            color: #333;
            font-size: 16px;
            font-weight: bold;
            margin: 0 0 10px 0;
        }

        .language-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 0;
        }

        .language-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            transition: all 0.3s ease;
        }

        .language-label.left {
            color: #006400;
            transform: scale(1.05);
        }

        .language-label.right {
            color: #666;
            transform: scale(1);
        }

        /* Toggle Switch - Smaller */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #006400 0%, #228B22 100%);
            transition: 0.4s;
            border-radius: 40px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .toggle-slider:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        input:checked + .toggle-slider {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .splash-language-btn {
            background: linear-gradient(135deg, #006400 0%, #228B22 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .splash-language-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        .splash-language-btn:active {
            transform: translateY(0);
        }

        .splash-cheese-float {
            position: absolute;
            font-size: 45px;
            animation: float 3s ease-in-out infinite;
        }

        .splash-cheese1 {
            top: -10px;
            left: 10px;
            animation-delay: 0s;
        }

        .splash-cheese2 {
            top: 5px;
            right: 15px;
            animation-delay: 1s;
        }

        .splash-cheese3 {
            bottom: -5px;
            left: 20px;
            animation-delay: 2s;
        }

        .splash-cheese4 {
            bottom: 10px;
            right: 10px;
            animation-delay: 1.5s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
            }
            50% {
                transform: translateY(-15px) rotate(5deg);
            }
        }

        .splash-sparkle {
            position: absolute;
            font-size: 28px;
            animation: sparkle 2s ease-in-out infinite;
        }

        .splash-sparkle1 {
            top: 5%;
            left: 5%;
            animation-delay: 0s;
        }

        .splash-sparkle2 {
            top: 5%;
            right: 5%;
            animation-delay: 0.7s;
        }

        .splash-sparkle3 {
            bottom: 8%;
            right: 5%;
            animation-delay: 1.4s;
        }

        .splash-sparkle4 {
            bottom: 8%;
            left: 5%;
            animation-delay: 0.5s;
        }

        .splash-cat {
            width: 70px;
            height: 70px;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
            flex-shrink: 0;
        }

        .splash-cat-left {
            animation: catBounceLeft 3s ease-in-out infinite;
        }

        .splash-cat-right {
            animation: catBounceRight 3s ease-in-out infinite;
            transform: scaleX(-1);
        }

        @keyframes catBounceLeft {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-5px) scale(1.05);
            }
        }

        @keyframes catBounceRight {
            0%, 100% {
                transform: scaleX(-1) translateY(0) scale(1);
            }
            50% {
                transform: scaleX(-1) translateY(-5px) scale(1.05);
            }
        }

        @keyframes sparkle {
            0%, 100% {
                opacity: 0;
                transform: scale(0.5);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        .splash-grid-prompt {
            color: #333;
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0 8px 0;
        }

        /* Two-column container for grid options */
        .splash-grid-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
            margin: 15px 0;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .splash-grid-column {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .splash-grid-column-left,
        .splash-grid-column-right {
            flex: 0 0 200px;
        }
        
        .splash-grid-column-left {
            background: rgba(34, 139, 34, 0.15);
            padding: 15px;
            border-radius: 12px;
        }
        
        .splash-grid-column-right {
            background: rgba(255, 215, 0, 0.15);
            padding: 15px;
            border-radius: 12px;
        }

        .splash-grid-column-center {
            flex: 0 0 auto;
            margin: 0 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .column-title {
            font-size: 15px;
            font-weight: bold;
            color: #006400;
            margin-bottom: 8px;
            text-align: center;
        }

        .splash-grid-options-left,
        .splash-grid-options-right {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .splash-grid-options-right {
            align-items: center;
        }

        /* Character container in center column */
        .splash-grid-column-center .splash-character-container {
            margin: 0;
            position: relative;
            width: 260px;
            height: 260px;
        }

        .splash-grid-column-center #splashMouse {
            width: 260px;
            height: 260px;
        }

        /* Language selector frame below mouse */
        .language-selector-frame {
            margin-top: 15px;
            padding: 10px 12px;
            border: 2px solid #006400;
            border-radius: 8px;
            background: rgba(240, 255, 240, 0.5);
        }
        
        .language-selector-frame .splash-language-prompt {
            font-size: 13px;
            margin: 0 0 6px 0;
        }
        
        .language-selector-frame .language-toggle {
            gap: 8px;
        }
        
        .language-selector-frame .language-label {
            font-size: 12px;
        }
        
        .language-selector-frame .toggle-switch {
            width: 40px;
            height: 22px;
        }
        
        .language-selector-frame .toggle-slider:before {
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
        }
        
        .language-selector-frame input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }


        .splash-grid-option {
            background: white;
            border: 2px solid #006400;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .splash-grid-option:hover {
            background: #e8f5e9;
            transform: translateY(-2px);
        }

        .splash-grid-option input[type="radio"] {
            cursor: pointer;
        }

        .splash-grid-option span {
            font-size: 13px;
            font-weight: bold;
            color: #333;
            text-align: center;
        }

        .splash-grid-option small {
            font-size: 10px;
            color: #666;
        }

        .splash-start-button {
            margin-top: 15px;
            display: flex;
            justify-content: center;
        }

        /* Instructions Page */
        .instructions-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #006400 0%, #228B22 50%, #FFD700 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            overflow-y: auto;
            transition: opacity 0.5s ease-out;
        }

        .instructions-page.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .instructions-container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .instructions-container h1 {
            color: #006400;
            text-align: center;
            margin-bottom: 30px;
        }

        .instructions-content {
            color: #333;
            font-size: 16px;
            line-height: 1.6;
            column-count: 2;
            column-gap: 40px;
        }

        .instructions-content h2 {
            color: #228B22;
            margin-top: 25px;
            margin-bottom: 15px;
            break-after: avoid;
        }

        .instructions-content ul {
            margin: 10px 0;
            padding-left: 30px;
            break-inside: avoid;
        }

        .instructions-content li {
            margin: 8px 0;
        }

        .instructions-content .command-example {
            background: #f0fff0;
            border-left: 4px solid #006400;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            break-inside: avoid;
        }

        /* Responsive: single column on narrow screens */
        @media (max-width: 768px) {
            .instructions-content {
                column-count: 1;
            }
        }

        .instructions-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
        }

        .instructions-btn {
            background: linear-gradient(135deg, #006400 0%, #228B22 100%);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }

        .instructions-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        .instructions-btn.skip {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
        }

        /* Help Button */
        .help-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: all 0.3s;
        }

        .help-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes noseWiggle {
            0%, 100% {
                transform: scale(1) rotate(0deg) translate(0, 0);
            }
            25% {
                transform: scale(1.15) rotate(-5deg) translate(-2px, -1px);
            }
            50% {
                transform: scale(1.2) rotate(0deg) translate(0, -2px);
            }
            75% {
                transform: scale(1.15) rotate(5deg) translate(2px, -1px);
            }
        }

        .nose-wiggle {
            animation: noseWiggle 0.3s ease-in-out 5;
            transform-origin: 100px 76px;
        }

        #gameContainer {
            opacity: 0;
            transition: opacity 0.5s ease-in 0.3s;
        }

        #gameContainer.visible {
            opacity: 1;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 30px;
        }

        .options-area {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
        }

        .options-container {
            background: #f5f5f5;
            border: 2px solid #ccc;
            border-radius: 10px;
            padding: 20px;
        }

        .options-container h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            text-align: center;
        }

        .radio-option {
            margin: 10px 0;
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-option:hover {
            background: #f0fff0;
        }

        .radio-option input[type="radio"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #006400;
        }

        .radio-option label {
            cursor: pointer;
            font-size: 14px;
            color: #333;
            user-select: none;
            line-height: 1.4;
        }

        .radio-option label small {
            color: #666;
            font-size: 11px;
        }

        .radio-option.selected {
            background: #e6f7e6;
            border-left: 4px solid #006400;
        }

        .game-area {
            flex: 0 0 auto;
        }

        .game-area h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            margin-top: 0;
            line-height: 1.3;
            font-size: 24px;
        }

        .command-area {
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
        }

        .command-list-container {
            background: #f5f5f5;
            border: 2px solid #ccc;
            border-radius: 10px;
            padding: 10px;
            min-height: 400px;
            max-height: 400px;
            margin-bottom: 15px;
            overflow-y: auto;
        }

        .command-list-container::-webkit-scrollbar {
            width: 8px;
        }

        .command-list-container::-webkit-scrollbar-track {
            background: #e0e0e0;
            border-radius: 10px;
        }

        .command-list-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .command-list-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .command-list-container h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
            text-align: center;
        }

        .command-item {
            background: white;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 4px solid #006400;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: context-menu;
            transition: all 0.2s;
        }

        .command-item:hover {
            background: #f0fff0;
            transform: translateX(3px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .command-item.highlighted {
            background: #fff3cd;
            border-left: 4px solid #ff6600;
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(255, 102, 0, 0.3);
        }

        .command-item .command-code {
            font-weight: bold;
            color: #006400;
            min-width: 25px;
        }

        .command-item .command-name {
            color: #666;
            font-size: 12px;
            flex: 1;
        }
        
        .command-item .multiplier {
            color: #FF8C00;
            font-weight: bold;
            font-size: 14px;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #executeBtn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        #executeBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        #clearBtn {
            background: linear-gradient(135deg, #ffa726 0%, #ff9800 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        #clearBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        #executeBtn:active, #clearBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #newGameBtn {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        #newGameBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        #newGameBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #attemptAgainBtn {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        #attemptAgainBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        #attemptAgainBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #returnMenuBtn {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        #returnMenuBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        #returnMenuBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Toggle Switch for Hint */
        .hint-toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 15px 0;
            padding: 10px;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .hint-toggle-label {
            font-weight: bold;
            color: #006400;
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #FFD700;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-slider:after {
            content: 'OFF';
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            font-weight: bold;
            color: #666;
        }

        input:checked + .toggle-slider:after {
            content: 'ON';
            left: 8px;
            right: auto;
            color: #006400;
        }

        /* Level Book Indicator */
        .level-indicator {
            text-align: center;
            margin: 15px 0;
            padding: 12px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-weight: bold;
            color: #006400;
            font-size: 16px;
        }

        /* Level Book option styling */
        .splash-grid-option.levelbook {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 3px solid #FF8C00;
            padding: 16px;
            min-width: 180px;
            justify-content: center;
        }

        .splash-grid-option.levelbook span {
            font-size: 15px;
        }

        .splash-grid-option.levelbook:hover {
            background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);
            transform: translateY(-3px) scale(1.03);
        }

        .splash-grid-option.levelbook input:checked ~ span {
            background: rgba(255, 140, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .grid {
            display: grid;
            gap: 2px;
            background-color: #ccc;
            padding: 2px;
            margin-bottom: 30px;
            border-radius: 5px;
            overflow: visible;
        }

        .cell {
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
        }

        .cheese {
            font-size: 35px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .trap {
            font-size: 47px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .wall {
            font-size: 45px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .cat {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 104%;
            height: 104%;
            pointer-events: none;
            z-index: 50;
            --attack-x: -50%;
            --attack-y: -50%;
            --original-rotation: 0deg;
            --attack-rotation: 0deg;
            --original-flip: 1;
            --attack-flip: 1;
        }

        .cat.attacking {
            animation: catAttack 1.6s ease-out;
            z-index: 500;
        }

        @keyframes catAttack {
            0% {
                transform: translate(-50%, -50%) scale(1) scaleX(var(--original-flip, 1)) rotate(var(--original-rotation, 0deg));
            }
            15% {
                transform: translate(-50%, -50%) scale(1.1) scaleX(var(--attack-flip, 1)) rotate(var(--attack-rotation, 0deg));
            }
            35% {
                transform: translate(var(--attack-x), var(--attack-y)) scale(1.3) scaleX(var(--attack-flip, 1)) rotate(var(--attack-rotation, 0deg));
            }
            50% {
                transform: translate(var(--attack-x), var(--attack-y)) scale(1.4) scaleX(var(--attack-flip, 1)) rotate(var(--attack-rotation, 0deg));
            }
            65% {
                transform: translate(var(--attack-x), var(--attack-y)) scale(1.3) scaleX(var(--attack-flip, 1)) rotate(var(--attack-rotation, 0deg));
            }
            85% {
                transform: translate(-50%, -50%) scale(1.1) scaleX(var(--original-flip, 1)) rotate(var(--original-rotation, 0deg));
            }
            100% {
                transform: translate(-50%, -50%) scale(1) scaleX(var(--original-flip, 1)) rotate(var(--original-rotation, 0deg));
            }
        }

        .message-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.95);
            color: #333;
            font-size: 48px;
            font-weight: bold;
            padding: 30px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            text-align: center;
            white-space: pre-line;
        }

        .message-overlay.celebration {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FFD700 100%);
            font-size: 36px;
            animation: fadeIn 0.5s ease-out;
        }

        .message-overlay.cat-caught {
            background: linear-gradient(135deg, #DC143C 0%, #8B0000 50%, #DC143C 100%);
            color: #FFFFFF;
            font-size: 36px;
            animation: fadeIn 0.5s ease-out;
            border: 4px solid #8B0000;
            box-shadow: 0 10px 40px rgba(139, 0, 0, 0.7);
        }

        .message-overlay.cat-caught::before {
            content: 'â˜ ï¸';
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 60px;
            opacity: 0.6;
        }

        .message-overlay.cat-caught::after {
            content: 'â˜ ï¸';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 60px;
            opacity: 0.6;
        }

        .celebration-emoticon {
            position: fixed;
            font-size: 60px;
            z-index: 1001;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateY(-200px) rotate(360deg);
            }
        }

        .token {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 60;
        }
        
        .token svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transition: transform 0.3s ease-out;
        }

        .token.move-up {
            animation: slideFromBelow 0.35s ease-out;
        }
        .token.move-down {
            animation: slideFromAbove 0.35s ease-out;
        }
        .token.move-left {
            animation: slideFromRight 0.35s ease-out;
        }
        .token.move-right {
            animation: slideFromLeft 0.35s ease-out;
        }

        @keyframes slideFromBelow {
            0% { transform: translate(-50%, 50%); opacity: 0.7; }
            100% { transform: translate(-50%, -50%); opacity: 1; }
        }
        @keyframes slideFromAbove {
            0% { transform: translate(-50%, -150%); opacity: 0.7; }
            100% { transform: translate(-50%, -50%); opacity: 1; }
        }
        @keyframes slideFromRight {
            0% { transform: translate(50%, -50%); opacity: 0.7; }
            100% { transform: translate(-50%, -50%); opacity: 1; }
        }
        @keyframes slideFromLeft {
            0% { transform: translate(-150%, -50%); opacity: 0.7; }
            100% { transform: translate(-50%, -50%); opacity: 1; }
        }

        @keyframes jump {
            0% {
                transform: translate(-50%, -50%) scale(1);
            }
            30% {
                transform: translate(-50%, -80%) scale(1.15);
            }
            50% {
                transform: translate(-50%, -90%) scale(1.2);
            }
            70% {
                transform: translate(-50%, -80%) scale(1.15);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .jumping {
            animation: jump 0.75s ease-in-out;
        }

        .token.jump-up {
            animation: jumpSlideUp 0.75s ease-out;
        }
        .token.jump-down {
            animation: jumpSlideDown 0.75s ease-out;
        }
        .token.jump-left {
            animation: jumpSlideLeft 0.75s ease-out;
        }
        .token.jump-right {
            animation: jumpSlideRight 0.75s ease-out;
        }

        @keyframes jumpSlideUp {
            0% { transform: translate(-50%, 150%) scale(1); }
            15% { transform: translate(-50%, 130%) scale(0.95, 1.05); }
            40% { transform: translate(-50%, -20%) scale(1.15); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes jumpSlideDown {
            0% { transform: translate(-50%, -250%) scale(1); }
            15% { transform: translate(-50%, -230%) scale(0.95, 1.05); }
            40% { transform: translate(-50%, -80%) scale(1.15); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes jumpSlideLeft {
            0% { transform: translate(150%, -50%) scale(1); }
            15% { transform: translate(130%, -50%) scale(1.05, 0.95); }
            40% { transform: translate(-80%, -50%) scale(1.15); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes jumpSlideRight {
            0% { transform: translate(-250%, -50%) scale(1); }
            15% { transform: translate(-230%, -50%) scale(1.05, 0.95); }
            40% { transform: translate(-20%, -50%) scale(1.15); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes tailWiggle {
            0%, 100% {
                transform: rotate(0deg);
            }
            25% {
                transform: rotate(-8deg);
            }
            75% {
                transform: rotate(8deg);
            }
        }

        .tail {
            animation: tailWiggle 1.2s ease-in-out infinite;
            transform-origin: 50px 85px;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .controls > .control-with-repeat > button {
            background: linear-gradient(135deg, #006400 0%, #228B22 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            padding: 15px 25px;
            min-width: 120px;
        }

        .controls > .control-with-repeat > button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .controls > .control-with-repeat > button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .control-with-repeat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .repeat-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 8px;
            border-radius: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .repeat-btn {
            min-width: auto;
            width: 24px;
            height: 24px;
            padding: 0;
            font-size: 18px;
            line-height: 1;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            color: white;
            font-weight: bold;
        }

        .repeat-btn:first-child {
            background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);
        }

        .repeat-btn:last-child {
            background: linear-gradient(135deg, #228B22 0%, #32CD32 100%);
        }

        .repeat-btn:hover {
            transform: scale(1.1);
        }

        .repeat-value {
            min-width: 20px;
            text-align: center;
            font-weight: bold;
            color: #006400;
            font-size: 16px;
        }

        .position {
            text-align: center;
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }

        /* ===== MOBILE FIXES ===== */
        @media (max-width: 1024px) {
            body {
                justify-content: flex-start;
                padding: 10px;
                box-sizing: border-box;
                overflow-x: hidden;
                overflow-y: auto;
                min-height: 100vh;
            }
            #splashScreen {
                overflow-y: auto;
                overflow-x: hidden;
                align-items: flex-start;
                padding: 10px;
                box-sizing: border-box;
            }
            .splash-container {
                margin: 8px auto;
                max-width: 100%;
                padding: 12px 15px;
                box-sizing: border-box;
            }
            .splash-title-frame {
                padding: 8px 12px;
                gap: 10px;
                margin-bottom: 8px;
            }
            .splash-title-main { font-size: 22px; }
            .splash-title-line1,
            .splash-title-line3 { font-size: 13px; }
            .splash-grid-container {
                gap: 10px;
                margin: 8px 0;
                flex-wrap: wrap;
                justify-content: center;
            }
            .splash-grid-column-left,
            .splash-grid-column-right {
                flex: 0 0 155px;
                padding: 10px;
            }
            .splash-grid-column-center .splash-character-container {
                width: 150px;
                height: 150px;
            }
            .splash-grid-column-center #splashMouse {
                width: 150px;
                height: 150px;
            }
            .splash-grid-option {
                padding: 6px 10px !important;
                font-size: 13px !important;
            }
            .splash-grid-option small { font-size: 10px !important; }
            .column-title { font-size: 13px; }
            .splash-language-btn {
                padding: 10px 25px;
                font-size: 16px;
            }
            .container {
                flex-direction: column;
                padding: 12px;
                gap: 12px;
                width: 100%;
                box-sizing: border-box;
            }
            .options-area { flex: none; width: 100%; }
            .game-area    { width: 100%; overflow-x: auto; }
            .command-area { flex: none; width: 100%; }
            #gameContainer { width: 100%; box-sizing: border-box; }
        }
    </style>
</head>
<body>
    <!-- ========================================
         SPLASH SCREEN - Language and Grid Selection
         ======================================== -->
    <!-- Splash Screen -->
    <div id="splashScreen">
        <div class="splash-container">
            <!-- Title Frame with Cats -->
            <div class="splash-title-frame">
                <!-- Left Cat SVG -->
                <svg class="splash-cat splash-cat-left" width="70" height="70" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="150" cy="175" rx="60" ry="45" fill="#f4a460"/>
                    <ellipse cx="150" cy="175" rx="55" ry="40" fill="#ffd9a8"/>
                    <ellipse cx="150" cy="110" rx="50" ry="45" fill="#f4a460"/>
                    <ellipse cx="150" cy="115" rx="42" ry="35" fill="#ffd9a8"/>
                    <g>
                        <path d="M105 70 L95 30 L130 55 Z" fill="#f4a460" stroke="#e8941d" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 115 60;-5 115 60;0 115 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                        <path d="M110 65 L103 35 L128 55 Z" fill="#ffb6c1">
                            <animateTransform attributeName="transform" type="rotate" values="0 115 60;-5 115 60;0 115 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                    </g>
                    <g>
                        <path d="M195 70 L205 30 L170 55 Z" fill="#f4a460" stroke="#e8941d" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 185 60;5 185 60;0 185 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                        <path d="M190 65 L197 35 L172 55 Z" fill="#ffb6c1">
                            <animateTransform attributeName="transform" type="rotate" values="0 185 60;5 185 60;0 185 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                    </g>
                    <ellipse cx="130" cy="105" rx="12" ry="14" fill="#90EE90"/>
                    <ellipse cx="130" cy="107" rx="5" ry="8" fill="#000"/>
                    <circle cx="128" cy="103" r="2" fill="#fff"/>
                    <ellipse cx="170" cy="105" rx="12" ry="14" fill="#90EE90"/>
                    <ellipse cx="170" cy="107" rx="5" ry="8" fill="#000"/>
                    <circle cx="168" cy="103" r="2" fill="#fff"/>
                    <path d="M150 125 L145 132 L155 132 Z" fill="#ff69b4"/>
                    <g>
                        <line x1="105" y1="125" x2="70" y2="115" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 105 125;3 105 125;-3 105 125;0 105 125" dur="2s" repeatCount="indefinite"/>
                        </line>
                        <line x1="105" y1="130" x2="70" y2="130" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 105 130;-2 105 130;2 105 130;0 105 130" dur="1.8s" repeatCount="indefinite"/>
                        </line>
                        <line x1="195" y1="125" x2="230" y2="115" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 195 125;-3 195 125;3 195 125;0 195 125" dur="2s" repeatCount="indefinite"/>
                        </line>
                        <line x1="195" y1="130" x2="230" y2="130" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 195 130;2 195 130;-2 195 130;0 195 130" dur="1.8s" repeatCount="indefinite"/>
                        </line>
                    </g>
                    <path d="M210 180 Q 240 160, 260 180 Q 280 200, 270 230" fill="none" stroke="#f4a460" stroke-width="12" stroke-linecap="round">
                        <animateTransform attributeName="transform" type="rotate" values="0 210 180;10 210 180;0 210 180;-10 210 180;0 210 180" dur="1.2s" repeatCount="indefinite"/>
                    </path>
                </svg>

                <div class="splash-title">
                    <div class="splash-title-line1" id="splashTitle1">ðŸ’» The Logical Adventures of</div>
                    <div class="splash-title-main" id="splashTitle2">Clever Manie Malan</div>
                    <div class="splash-title-line3" id="splashTitle3">the Coding Mouse ðŸ’»</div>
                </div>
                
                <!-- Right Cat SVG -->
                <svg class="splash-cat splash-cat-right" width="70" height="70" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="150" cy="175" rx="60" ry="45" fill="#f4a460"/>
                    <ellipse cx="150" cy="175" rx="55" ry="40" fill="#ffd9a8"/>
                    <ellipse cx="150" cy="110" rx="50" ry="45" fill="#f4a460"/>
                    <ellipse cx="150" cy="115" rx="42" ry="35" fill="#ffd9a8"/>
                    <g>
                        <path d="M105 70 L95 30 L130 55 Z" fill="#f4a460" stroke="#e8941d" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 115 60;-5 115 60;0 115 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                        <path d="M110 65 L103 35 L128 55 Z" fill="#ffb6c1">
                            <animateTransform attributeName="transform" type="rotate" values="0 115 60;-5 115 60;0 115 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                    </g>
                    <g>
                        <path d="M195 70 L205 30 L170 55 Z" fill="#f4a460" stroke="#e8941d" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 185 60;5 185 60;0 185 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                        <path d="M190 65 L197 35 L172 55 Z" fill="#ffb6c1">
                            <animateTransform attributeName="transform" type="rotate" values="0 185 60;5 185 60;0 185 60" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                    </g>
                    <ellipse cx="130" cy="105" rx="12" ry="14" fill="#90EE90"/>
                    <ellipse cx="130" cy="107" rx="5" ry="8" fill="#000"/>
                    <circle cx="128" cy="103" r="2" fill="#fff"/>
                    <ellipse cx="170" cy="105" rx="12" ry="14" fill="#90EE90"/>
                    <ellipse cx="170" cy="107" rx="5" ry="8" fill="#000"/>
                    <circle cx="168" cy="103" r="2" fill="#fff"/>
                    <path d="M150 125 L145 132 L155 132 Z" fill="#ff69b4"/>
                    <g>
                        <line x1="105" y1="125" x2="70" y2="115" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 105 125;3 105 125;-3 105 125;0 105 125" dur="2s" repeatCount="indefinite"/>
                        </line>
                        <line x1="105" y1="130" x2="70" y2="130" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 105 130;-2 105 130;2 105 130;0 105 130" dur="1.8s" repeatCount="indefinite"/>
                        </line>
                        <line x1="195" y1="125" x2="230" y2="115" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 195 125;-3 195 125;3 195 125;0 195 125" dur="2s" repeatCount="indefinite"/>
                        </line>
                        <line x1="195" y1="130" x2="230" y2="130" stroke="#444" stroke-width="2">
                            <animateTransform attributeName="transform" type="rotate" values="0 195 130;2 195 130;-2 195 130;0 195 130" dur="1.8s" repeatCount="indefinite"/>
                        </line>
                    </g>
                    <path d="M210 180 Q 240 160, 260 180 Q 280 200, 270 230" fill="none" stroke="#f4a460" stroke-width="12" stroke-linecap="round">
                        <animateTransform attributeName="transform" type="rotate" values="0 210 180;10 210 180;0 210 180;-10 210 180;0 210 180" dur="1.2s" repeatCount="indefinite"/>
                    </path>
                </svg>
            </div>
            
            <div class="splash-grid-prompt" id="splashGridPrompt">Select Grid Size or Level Book</div>
            
            <div class="splash-grid-container">
                <!-- LEFT COLUMN: Random Grid Sizes -->
                <div class="splash-grid-column splash-grid-column-left">
                    <h3 class="column-title">Random Mode</h3>
                    <div class="splash-grid-options-left">
                        <label class="splash-grid-option">
                            <input type="radio" name="splashGridSize" value="1" checked onchange="wiggleSplashNose()">
                            <span>3 Ã— 4<br><small>1 ðŸ§€</small></span>
                        </label>
                        <label class="splash-grid-option">
                            <input type="radio" name="splashGridSize" value="2" onchange="wiggleSplashNose()">
                            <span>4 Ã— 4<br><small>1 ðŸ§€, 1 ðŸ§±</small></span>
                        </label>
                        <label class="splash-grid-option">
                            <input type="radio" name="splashGridSize" value="3" onchange="wiggleSplashNose()">
                            <span>5 Ã— 5<br><small>1 ðŸ§€, 1 ðŸª¤, 3 ðŸ§±, 1 ðŸ±</small></span>
                        </label>
                        <label class="splash-grid-option">
                            <input type="radio" name="splashGridSize" value="4" onchange="wiggleSplashNose()">
                            <span>5 Ã— 7<br><small>2 ðŸ§€, 3 ðŸª¤, 5 ðŸ§±, 1 ðŸ±</small></span>
                        </label>
                    </div>
                </div>
                
                <!-- CENTER: Mouse Character -->
                <div class="splash-grid-column splash-grid-column-center">
                    <div class="splash-character-container">
                        <div class="splash-cheese-float splash-cheese1">ðŸ§€</div>
                        <div class="splash-cheese-float splash-cheese2">ðŸ§€</div>
                        <div class="splash-cheese-float splash-cheese3">ðŸ§€</div>
                        <div class="splash-cheese-float splash-cheese4">ðŸ§€</div>
                        
                        <div class="splash-sparkle splash-sparkle1">âœ¨</div>
                        <div class="splash-sparkle splash-sparkle2">âœ¨</div>
                        <div class="splash-sparkle splash-sparkle3">âœ¨</div>
                        <div class="splash-sparkle splash-sparkle4">âœ¨</div>

                        <!-- Manie Malan SVG -->
                        <svg id="splashMouse" width="260" height="260" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" style="cursor: pointer;" onclick="wiggleSplashNose()">
                            <!-- Green Cape (behind mouse) with flowing animation -->
                            <path d="M 100 60 Q 70 80, 50 120 L 50 140 Q 50 145, 55 145 L 145 145 Q 150 145, 150 140 L 150 120 Q 130 80, 100 60 Z" 
                                  fill="#006400" stroke="#004d00" stroke-width="2">
                                <animate attributeName="d" 
                                    values="M 100 60 Q 70 80, 50 120 L 50 140 Q 50 145, 55 145 L 145 145 Q 150 145, 150 140 L 150 120 Q 130 80, 100 60 Z;
                                            M 100 60 Q 65 82, 48 122 L 48 142 Q 48 147, 53 147 L 147 147 Q 152 147, 152 142 L 152 122 Q 135 82, 100 60 Z;
                                            M 100 60 Q 75 78, 52 118 L 52 138 Q 52 143, 57 143 L 143 143 Q 148 143, 148 138 L 148 118 Q 125 78, 100 60 Z;
                                            M 100 60 Q 70 80, 50 120 L 50 140 Q 50 145, 55 145 L 145 145 Q 150 145, 150 140 L 150 120 Q 130 80, 100 60 Z" 
                                    dur="2.5s" 
                                    repeatCount="indefinite"/>
                            </path>
                            
                            <!-- Cape collar with subtle movement -->
                            <ellipse cx="100" cy="65" rx="35" ry="8" fill="#228B22" stroke="#004d00" stroke-width="1.5">
                                <animate attributeName="ry" 
                                    values="8;9;7.5;8" 
                                    dur="2.5s" 
                                    repeatCount="indefinite"/>
                            </ellipse>
                            
                            <!-- Mouse Body -->
                            <ellipse cx="100" cy="100" rx="40" ry="50" fill="#C0C0C0" stroke="#808080" stroke-width="2"/>
                            
                            <!-- Left Ear -->
                            <ellipse cx="75" cy="55" rx="18" ry="22" fill="#FFB6C1" stroke="#808080" stroke-width="2"/>
                            <ellipse cx="75" cy="55" rx="11" ry="14" fill="#FFC0CB"/>
                            
                            <!-- Right Ear -->
                            <ellipse cx="125" cy="55" rx="18" ry="22" fill="#FFB6C1" stroke="#808080" stroke-width="2"/>
                            <ellipse cx="125" cy="55" rx="11" ry="14" fill="#FFC0CB"/>
                            
                            <!-- Head -->
                            <ellipse cx="100" cy="75" rx="32" ry="35" fill="#C0C0C0" stroke="#808080" stroke-width="2"/>
                            
                            <!-- Eyes -->
                            <circle cx="90" cy="65" r="4" fill="#000000"/>
                            <circle cx="91" cy="64" r="1.5" fill="#FFFFFF"/>
                            <circle cx="110" cy="65" r="4" fill="#000000"/>
                            <circle cx="111" cy="64" r="1.5" fill="#FFFFFF"/>
                            
                            <!-- Snout -->
                            <ellipse cx="100" cy="78" rx="15" ry="12" fill="#B0B0B0"/>
                            
                            <!-- Nose -->
                            <circle id="splashNose" cx="100" cy="76" r="4" fill="#FF69B4"/>
                            
                            <!-- Smile -->
                            <path d="M 90 92 Q 100 97, 110 92" fill="none" stroke="#000000" stroke-width="1.5" stroke-linecap="round"/>
                            
                            <!-- Teeth -->
                            <rect x="97" y="94" width="3" height="4" fill="#FFFFFF" stroke="#000000" stroke-width="0.5"/>
                            <rect x="101" y="94" width="3" height="4" fill="#FFFFFF" stroke="#000000" stroke-width="0.5"/>
                            
                            <!-- Whiskers -->
                            <line x1="70" y1="70" x2="50" y2="68" stroke="#404040" stroke-width="1.5"/>
                            <line x1="70" y1="75" x2="50" y2="75" stroke="#404040" stroke-width="1.5"/>
                            <line x1="130" y1="70" x2="150" y2="68" stroke="#404040" stroke-width="1.5"/>
                            <line x1="130" y1="75" x2="150" y2="75" stroke="#404040" stroke-width="1.5"/>
                            
                            <!-- Tail with wiggle animation -->
                            <g>
                                <path d="M 135 110 Q 150 115, 155 120 Q 160 125, 158 130" 
                                      fill="none" stroke="#A0826D" stroke-width="3" stroke-linecap="round">
                                    <animateTransform attributeName="transform" type="rotate" 
                                        values="0 135 110; 8 135 110; -8 135 110; 0 135 110" 
                                        dur="1.2s" repeatCount="indefinite"/>
                                </path>
                            </g>
                            
                            <!-- Arms/Paws -->
                            <ellipse cx="65" cy="100" rx="12" ry="18" fill="#C0C0C0" stroke="#808080" stroke-width="1.5"/>
                            <ellipse cx="135" cy="100" rx="12" ry="18" fill="#C0C0C0" stroke="#808080" stroke-width="1.5"/>
                            
                            <!-- Feet -->
                            <ellipse cx="85" cy="145" rx="12" ry="8" fill="#FFB6C1" stroke="#808080" stroke-width="1.5"/>
                            <ellipse cx="115" cy="145" rx="12" ry="8" fill="#FFB6C1" stroke="#808080" stroke-width="1.5"/>
                        </svg>
                    </div>
                    
                    <!-- Language Selector Frame Below Mouse -->
                    <div class="language-selector-frame">
                        <div class="splash-language-prompt" id="splashLanguagePrompt">Select Your Language</div>
                        <div class="language-toggle">
                            <span class="language-label left">English</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="languageToggle" onchange="toggleLanguage()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="language-label right">Afrikaans</span>
                        </div>
                    </div>
                    
                    <!-- Start Game Button Below Language Selector -->
                    <div class="splash-start-button">
                        <button class="splash-language-btn" id="splashStartBtn" onclick="startGame()">Start Game</button>
                    </div>
                </div>
                
                <!-- RIGHT COLUMN: Level Book -->
                <div class="splash-grid-column splash-grid-column-right">
                    <h3 class="column-title">Level Book Mode</h3>
                    <div class="splash-grid-options-right">
                        <label class="splash-grid-option levelbook">
                            <input type="radio" name="splashGridSize" value="levelbook" onchange="wiggleSplashNose()">
                            <span>ðŸ“š Level Book<br><small id="levelBookLabel">15 Challenges</small></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Instructions Page -->
    <div id="instructionsPage" class="instructions-page hidden">
        <div class="instructions-container">
            <h1 id="instructionsTitle">How to Play</h1>
            
            <div id="instructionsContent" class="instructions-content">
                <!-- Content will be populated by JavaScript -->
            </div>
            
            <div class="instructions-buttons">
                <button class="instructions-btn skip" onclick="showGame()">â–¶ Play Game</button>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer">
    <button class="help-button" onclick="showInstructions()" title="Help">â“</button>
    <div id="messageOverlay" class="message-overlay"></div>
    <div class="container">
        <div class="game-area">
            <h1>
                <span style="color: #006400; font-size: 20px;">ðŸ’» The Logical Adventures of</span><br>
                <span style="color: #FFD700; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); font-size: 32px; font-weight: bold;">Clever Manie Malan</span><br>
                <span style="color: #006400; font-size: 20px;">the Coding Mouse ðŸ’»</span>
            </h1>
            
            <div class="grid" id="grid"></div>
            
            <div class="controls">
                <div class="control-with-repeat">
                    <button id="turnLeft" onclick="addCommand('L')">â†¶ Turn Left</button>
                    <div class="repeat-control">
                        <button class="repeat-btn" onclick="changeRepeat('L', -1)">âˆ’</button>
                        <span class="repeat-value" id="repeat-L">1</span>
                        <button class="repeat-btn" onclick="changeRepeat('L', 1)">+</button>
                    </div>
                </div>
                
                <div class="control-with-repeat">
                    <button id="forward" onclick="addCommand('F')">â†‘ Forward</button>
                    <div class="repeat-control">
                        <button class="repeat-btn" onclick="changeRepeat('F', -1)">âˆ’</button>
                        <span class="repeat-value" id="repeat-F">1</span>
                        <button class="repeat-btn" onclick="changeRepeat('F', 1)">+</button>
                    </div>
                </div>
                
                <div class="control-with-repeat">
                    <button id="jump" onclick="addCommand('J')">â¤Š Jump</button>
                    <div class="repeat-control">
                        <button class="repeat-btn" onclick="changeRepeat('J', -1)">âˆ’</button>
                        <span class="repeat-value" id="repeat-J">1</span>
                        <button class="repeat-btn" onclick="changeRepeat('J', 1)">+</button>
                    </div>
                </div>
                
                <div class="control-with-repeat">
                    <button id="eat" onclick="addCommand('E')">ðŸ§€ Eat</button>
                    <div class="repeat-control">
                        <button class="repeat-btn" onclick="changeRepeat('E', -1)">âˆ’</button>
                        <span class="repeat-value" id="repeat-E">1</span>
                        <button class="repeat-btn" onclick="changeRepeat('E', 1)">+</button>
                    </div>
                </div>
                
                <div class="control-with-repeat">
                    <button id="turnRight" onclick="addCommand('R')">â†· Turn Right</button>
                    <div class="repeat-control">
                        <button class="repeat-btn" onclick="changeRepeat('R', -1)">âˆ’</button>
                        <span class="repeat-value" id="repeat-R">1</span>
                        <button class="repeat-btn" onclick="changeRepeat('R', 1)">+</button>
                    </div>
                </div>
            </div>

            <!-- Hint Toggle Switch -->
            <div class="hint-toggle-container">
                <span class="hint-toggle-label" id="hintToggleLabel">ðŸ’¡ Show L/R:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="hintToggle" onchange="toggleHint()">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <!-- Level Book Indicator (hidden in random mode) -->
            <!-- Triple-click to activate level skip cheat -->
            <div id="levelIndicator" class="level-indicator" style="display: none;" ondblclick="levelSkipCheat()">
                <span id="levelIndicatorText">ðŸ“š Level 1 of 15</span>
            </div>

            <div class="position">
                <span id="positionLabel">Position:</span> <span id="position"></span>
            </div>
            
            <div style="text-align: center; margin-top: 10px; color: #888; font-size: 12px;">
                Keyboard (immediate): A/â† (Left) | D/â†’ (Right) | W/â†‘ (Forward) | Space (Jump) | E (Eat)
            </div>
        </div>

        <div class="command-area">
            <div class="command-list-container">
                <h3>Command List</h3>
                <div id="commandList"></div>
            </div>
            <div style="text-align: center; margin-bottom: 10px; color: #888; font-size: 11px;">
                Click a command to select, click again to remove
            </div>
            <div class="action-buttons">
                <button id="executeBtn" onclick="executeCommands()">â–¶ Execute</button>
                <button id="attemptAgainBtn" onclick="attemptAgain()">ðŸ”„ Attempt Again</button>
                <button id="clearBtn" onclick="clearCommands()">âœ• Clear</button>
                <button id="newGameBtn" onclick="newGame()">ðŸŽ® New Game</button>
                <button id="returnMenuBtn" onclick="returnToMenu()">ðŸ  Return to Menu</button>
            </div>
        </div>
    </div>
    </div> <!-- End gameContainer -->

    <!-- ========================================
         JAVASCRIPT - Game Logic and Functionality
         ======================================== -->
    <script>
        // ===================================================================
        // SECTION 1: LANGUAGE SYSTEM
        // ===================================================================
        // Manages bilingual support (English/Afrikaans) throughout the game
        // All user-facing text is stored in the translations object
        
        let currentLanguage = 'en'; // Current language: 'en' or 'af'
        let selectedGridSize = 1; // Store selected grid difficulty from splash screen
        
        // Translation object containing all text for both languages
        const translations = {
            en: {
                title1: 'ðŸ’» The Logical Adventures of',
                title2: 'Clever Manie Malan',
                title3: 'the Coding Mouse ðŸ’»',
                start: 'START',
                stop: 'STOP',
                splashTitle1: 'ðŸ’» The Logical Adventures of',
                splashTitle2: 'Clever Manie Malan',
                splashTitle3: 'the Coding Mouse ðŸ’»',
                splashLanguagePrompt: 'Select Your Language',
                splashGridPrompt: 'Select Grid Size or Level Book',
                splashStartButton: 'Start Game',
                instructionsTitle: 'How to Play',
                welcomeMessage: 'Write code to help Clever Manie Malan collect all the cheese! ðŸ§€\nWatch out for the traps! ðŸª¤ Beware of the sneaky CAT! ðŸ±',
                instructionsContent: `
                    <h2>ðŸŽ¯ Objective</h2>
                    <p>Help Manie Malan collect all the cheese ðŸ§€ while avoiding mouse traps ðŸª¤!</p>
                    
                    <h2>ðŸŽ® Commands</h2>
                    <ul>
                        <li><strong>â†¶ Turn Left</strong> - Rotate 90Â° counterclockwise</li>
                        <li><strong>â†‘ Forward</strong> - Move one cell in the direction you're facing</li>
                        <li><strong>â¤Š Jump</strong> - Jump over one cell (useful for obstacles)</li>
                        <li><strong>ðŸ§€ Eat</strong> - Collect cheese if you're on a cheese tile</li>
                        <li><strong>â†· Turn Right</strong> - Rotate 90Â° clockwise</li>
                    </ul>
                    
                    <h2>ðŸ”„ Repeat Controls</h2>
                    <p>Use the <strong>âˆ’ 1 +</strong> buttons below each command to repeat it multiple times:</p>
                    <div class="command-example">
                        Click + to change to 3, then click Forward â†’ adds "Forward âœ– 3"<br>
                        This runs Forward 3 times in a row!
                    </div>
                    
                    <h2>ðŸ“‹ Programming</h2>
                    <ul>
                        <li>Your program always starts with <strong style="color: #e53935;">START</strong></li>
                        <li>Add commands in between (they appear indented)</li>
                        <li>Your program always ends with <strong style="color: #43a047;">STOP</strong></li>
                        <li><strong>Right-click</strong> any command to remove it</li>
                    </ul>
                    
                    <h2>â–¶ Running Your Program</h2>
                    <ul>
                        <li><strong>Execute</strong> - Run your program and see what happens</li>
                        <li><strong>Attempt Again</strong> - Reset position and try again with same commands</li>
                        <li><strong>Clear</strong> - Remove all commands</li>
                        <li><strong>New Game</strong> - Start fresh with new cheese positions</li>
                    </ul>
                    
                    <h2>âŒ¨ï¸ Keyboard Shortcuts</h2>
                    <p>For immediate actions (not added to program):</p>
                    <ul>
                        <li><strong>A or â†</strong> - Turn Left</li>
                        <li><strong>D or â†’</strong> - Turn Right</li>
                        <li><strong>W or â†‘</strong> - Forward</li>
                        <li><strong>Space</strong> - Jump</li>
                        <li><strong>E</strong> - Eat</li>
                    </ul>
                    
                    <h2>âš ï¸ Watch Out!</h2>
                    <p><strong>Mouse Traps ðŸª¤:</strong> If you step on a trap, the game ends and resets. Use the Jump command to leap over traps - but be careful where you land!</p>
                    <p><strong>Walls ðŸ§±:</strong> Manie cannot walk through walls or jump over them. You must go around walls to reach the cheese!</p>
                    <p><strong>The Cat ðŸ±:</strong> DANGER! The cat has a danger zone - all 9 cells around it! If Manie enters any of these cells, the cat will pounce!</p>
                    <div class="command-example" style="text-align: center; font-family: monospace;">
                        <strong>Cat Danger Zone:</strong><br>
                        âš ï¸ âš ï¸ âš ï¸<br>
                        âš ï¸ ðŸ± âš ï¸<br>
                        âš ï¸ âš ï¸ âš ï¸
                    </div>
                `,
                turnLeft: 'â†¶ Turn Left',
                forward: 'â†‘ Forward',
                jump: 'â¤Š Jump',
                eat: 'ðŸ§€ Eat',
                turnRight: 'â†· Turn Right',
                execute: 'â–¶ Execute',
                attemptAgain: 'ðŸ”„ Attempt Again',
                hintToggle: 'ðŸ’¡ Show L/R:',
                levelBookLabel: '15 Challenges',
                clear: 'âœ• Clear',
                newGame: 'ðŸŽ® New Game',
                returnMenu: 'ðŸ  Return to Menu',
                gridSize: 'Grid Size',
                commandList: 'Command List',
                position: 'Position',
                row: 'Row',
                col: 'Col',
                cheese: 'cheese',
                trap: 'trap',
                traps: 'traps',
                rightClickRemove: 'Click to select, click again to remove (START/STOP cannot be removed)',
                keyboard: 'Keyboard (immediate): A/â† (Left) | D/â†’ (Right) | W/â†‘ (Forward) | Space (Jump) | E (Eat)',
                njomNjom: 'Njom Njom! ðŸ˜‹',
                wellDone: 'ðŸŽ‰ WELL DONE! ðŸŽ‰\nAll cheese collected!! ðŸ§€âœ¨',
                gameOver: 'ðŸ’¥ OH NO!! ðŸ’¥\nYou hit a trap!\nGame Over - Try Again!',
                wallHit: 'ðŸ’¥ OOPS! You hit a wall! ðŸ’¥\nManie can\'t jump over or go through walls!',
                trapJump: 'ðŸ’¥ OOPS! You can\'t jump over a trap! ðŸ’¥\nManie must walk around traps!',
                catCaught: 'â˜ ï¸ OH NO! â˜ ï¸\nYou have been caught by the CAT!\nGame Over - Try Again!',
                commands: {
                    F: 'Forward',
                    J: 'Jump',
                    R: 'Turn Right',
                    L: 'Turn Left',
                    E: 'Eat'
                }
            },
            af: {
                title1: 'ðŸ’» Die Slim Avonture van',
                title2: 'Manie Malan',
                title3: 'die Koderings-Muis ðŸ’»',
                start: 'BEGIN',
                stop: 'STOP',
                splashTitle1: 'ðŸ’» Die Slim Avonture van',
                splashTitle2: 'Manie Malan',
                splashTitle3: 'die Koderings-Muis ðŸ’»',
                splashLanguagePrompt: 'Kies Jou Taal',
                splashGridPrompt: 'Kies Rooster Grootte of Vlak Boek',
                splashStartButton: 'Begin Spel',
                instructionsTitle: 'Hoe om te Speel',
                welcomeMessage: 'Skryf die kode om Slim Manie Malan te help om al die kaas te versamel! ðŸ§€\nOppas vir die strikke! ðŸª¤ Pasop vir die skelm KAT! ðŸ±',
                instructionsContent: `
                    <h2>ðŸŽ¯ Doelwit</h2>
                    <p>Help Manie Malan om al die kaas ðŸ§€ te versamel terwyl jy muisvalle ðŸª¤ vermy!</p>
                    
                    <h2>ðŸŽ® Bevele</h2>
                    <ul>
                        <li><strong>â†¶ Draai Links</strong> - Roteer 90Â° anti-kloksgewys</li>
                        <li><strong>â†‘ Vorentoe</strong> - Beweeg een sel in die rigting wat jy kyk</li>
                        <li><strong>â¤Š Spring</strong> - Spring oor een sel (nuttig vir struikelblokke)</li>
                        <li><strong>ðŸ§€ Eet</strong> - Versamel kaas as jy op 'n kaas teÃ«l is</li>
                        <li><strong>â†· Draai Regs</strong> - Roteer 90Â° kloksgewys</li>
                    </ul>
                    
                    <h2>ðŸ”„ Herhaal Kontroles</h2>
                    <p>Gebruik die <strong>âˆ’ 1 +</strong> knoppies onder elke bevel om dit verskeie kere te herhaal:</p>
                    <div class="command-example">
                        Kliek + tot dit 3 wys, dan kliek Vorentoe<br>
                        Dit voeg "Vorentoe âœ– 3" by die lys<br>
                        Die muis sal dan 3 keer vorentoe beweeg!
                    </div>
                    
                    <h2>ðŸ“‹ Programmering</h2>
                    <ul>
                        <li>Jou program begin altyd met <strong style="color: #e53935;">BEGIN</strong></li>
                        <li>Voeg bevele tussenin by (hulle verskyn ingekeep)</li>
                        <li>Jou program eindig altyd met <strong style="color: #43a047;">STOP</strong></li>
                        <li><strong>Regskliek</strong> enige bevel om dit te verwyder</li>
                    </ul>
                    
                    <h2>â–¶ Jou Program Laat Loop</h2>
                    <ul>
                        <li><strong>Voer Uit</strong> - Laat jou program loop en kyk wat gebeur</li>
                        <li><strong>Probeer Weer</strong> - Stel posisie terug en probeer weer met dieselfde bevele</li>
                        <li><strong>Maak Skoon</strong> - Verwyder alle bevele</li>
                        <li><strong>Nuwe Spel</strong> - Begin vars met nuwe kaas posisies</li>
                    </ul>
                    
                    <h2>âŒ¨ï¸ Sleutelbord Kortpaaie</h2>
                    <p>Vir onmiddellike aksies (nie by program gevoeg nie):</p>
                    <ul>
                        <li><strong>A of â†</strong> - Draai Links</li>
                        <li><strong>D of â†’</strong> - Draai Regs</li>
                        <li><strong>W of â†‘</strong> - Vorentoe</li>
                        <li><strong>Spasie</strong> - Spring</li>
                        <li><strong>E</strong> - Eet</li>
                    </ul>
                    
                    <h2>âš ï¸ Pas Op!</h2>
                    <p><strong>Muisvalle ðŸª¤:</strong> As jy op 'n muisval trap, eindig die spel en stel terug. Gebruik die Spring opdrag om oor valle te spring - maar wees versigtig waar jy land!</p>
                    <p><strong>Mure ðŸ§±:</strong> Manie kan nie deur mure loop of oor mure spring nie. Jy moet om mure loop om by die kaas uit te kom!</p>
                    <p><strong>Die Kat ðŸ±:</strong> GEVAAR! Die kat het 'n gevaarsone - al 9 selle rondom hom! As Manie enige van hierdie selle binnegaan, sal die kat spring!</p>
                    <div class="command-example" style="text-align: center; font-family: monospace;">
                        <strong>Kat Gevaarsone:</strong><br>
                        âš ï¸ âš ï¸ âš ï¸<br>
                        âš ï¸ ðŸ± âš ï¸<br>
                        âš ï¸ âš ï¸ âš ï¸
                    </div>
                `,
                turnLeft: 'â†¶ Draai Links',
                forward: 'â†‘ Vorentoe',
                jump: 'â¤Š Spring',
                eat: 'ðŸ§€ Eet',
                turnRight: 'â†· Draai Regs',
                execute: 'â–¶ Voer Uit',
                attemptAgain: 'ðŸ”„ Probeer Weer',
                hintToggle: 'ðŸ’¡ Wys L/R:',
                levelBookLabel: '15 Uitdagings',
                clear: 'âœ• Maak Skoon',
                newGame: 'ðŸŽ® Nuwe Spel',
                returnMenu: 'ðŸ  Terug na Kieslys',
                gridSize: 'Rooster Grootte',
                commandList: 'Bevel Lys',
                position: 'Posisie',
                row: 'Ry',
                col: 'Kolom',
                cheese: 'kaas',
                trap: 'strik',
                traps: 'strikke',
                rightClickRemove: 'Klik om te kies, klik weer om te verwyder (BEGIN/STOP kan nie verwyder word nie)',
                keyboard: 'Sleutelbord (onmiddellik): A/â† (Links) | D/â†’ (Regs) | W/â†‘ (Vorentoe) | Spasie (Spring) | E (Eet)',
                njomNjom: 'Njom Njom! ðŸ˜‹',
                wellDone: 'ðŸŽ‰ GOED SO! ðŸŽ‰\nAl die kaas versamel!! ðŸ§€âœ¨',
                gameOver: 'ðŸ’¥ AG NEE!! ðŸ’¥\nJy het \'n strik getref!\nSpel Verby - Probeer Weer!',
                wallHit: 'ðŸ’¥ OEPS! Jy het \'n muur getref! ðŸ’¥\nManie kan nie oor mure spring of deur mure gaan nie!',
                trapJump: 'ðŸ’¥ OEPS! Jy kan nie oor \'n strik spring nie! ðŸ’¥\nManie moet om strikke loop!',
                catCaught: 'â˜ ï¸ AG NEE! â˜ ï¸\nJy is deur die KAT gevang!\nSpel Verby - Probeer Weer!',
                commands: {
                    V: 'Vorentoe',
                    S: 'Spring',
                    R: 'Draai Regs',
                    L: 'Draai Links',
                    E: 'Eet'
                }
            }
        };

        // Command code mapping based on language
        const commandCodes = {
            en: { forward: 'F', jump: 'J', turnRight: 'R', turnLeft: 'L', eat: 'E' },
            af: { forward: 'V', jump: 'S', turnRight: 'R', turnLeft: 'L', eat: 'E' }
        };

        function toggleLanguage() {
            const toggle = document.getElementById('languageToggle');
            currentLanguage = toggle.checked ? 'af' : 'en';
            
            // Update label colors
            const leftLabel = document.querySelector('.language-label.left');
            const rightLabel = document.querySelector('.language-label.right');
            
            if (currentLanguage === 'en') {
                leftLabel.style.color = '#006400';
                leftLabel.style.transform = 'scale(1.1)';
                rightLabel.style.color = '#666';
                rightLabel.style.transform = 'scale(1)';
            } else {
                leftLabel.style.color = '#666';
                leftLabel.style.transform = 'scale(1)';
                rightLabel.style.color = '#FFA500';
                rightLabel.style.transform = 'scale(1.1)';
            }
            
            // Update splash screen text
            updateSplashText();
            
            // Wiggle the nose!
            wiggleSplashNose();
        }

        function wiggleSplashNose() {
            const nose = document.getElementById('splashNose');
            if (nose) {
                // Remove class if it exists
                nose.classList.remove('nose-wiggle');
                // Force reflow to restart animation
                void nose.offsetWidth;
                // Add class to trigger animation
                nose.classList.add('nose-wiggle');
                // Remove class after animation completes (5 iterations * 0.3s = 1.5s)
                setTimeout(() => {
                    nose.classList.remove('nose-wiggle');
                }, 1500);
            }
        }

        function updateSplashText() {
            const t = translations[currentLanguage];
            document.getElementById('splashTitle1').textContent = t.splashTitle1;
            document.getElementById('splashTitle2').textContent = t.splashTitle2;
            document.getElementById('splashTitle3').textContent = t.splashTitle3;
            document.getElementById('splashLanguagePrompt').textContent = t.splashLanguagePrompt;
            document.getElementById('splashGridPrompt').textContent = t.splashGridPrompt;
            document.getElementById('splashStartBtn').textContent = t.splashStartButton;
        }

        function startGame() {
            // Get selected grid size
            const selectedRadio = document.querySelector('input[name="splashGridSize"]:checked');
            const selectedValue = selectedRadio.value;
            
            // Check if Level Book mode is selected
            if (selectedValue === 'levelbook') {
                isLevelBookMode = true;
                currentLevelBookLevel = 1; // Start at level 1
                selectedGridSize = 3; // Use a placeholder, will be overridden by Level Book
            } else {
                isLevelBookMode = false;
                selectedGridSize = parseInt(selectedValue);
            }
            
            // Hide splash screen
            document.getElementById('splashScreen').classList.add('hidden');
            
            // Go straight to game (skip instructions)
            setTimeout(() => {
                showGame();
            }, 300);
        }

        function showInstructions() {
            // Hide game, show instructions
            document.getElementById('gameContainer').classList.remove('visible');
            document.getElementById('instructionsPage').classList.remove('hidden');
            updateInstructionsContent();
        }

        function showGame() {
            // Hide instructions
            document.getElementById('instructionsPage').classList.add('hidden');
            
            const gameContainer = document.getElementById('gameContainer');
            
            // Remove any inline opacity style that might have been set by returnToMenu
            gameContainer.style.opacity = '';
            
            // Show game container
            setTimeout(() => {
                gameContainer.classList.add('visible');
            }, 300);
            
            // Always initialize/reinitialize the game
            setTimeout(() => {
                // If Level Book mode, load first level; otherwise use selected grid
                if (isLevelBookMode) {
                    loadLevelFromBook(currentLevelBookLevel);
                } else {
                    selectGridSize(selectedGridSize);
                }
                applyTranslations();
                updateCommandListDisplay();
                updateLevelIndicator(); // Update level indicator display
                
                // Show welcome message
                setTimeout(() => {
                    const t = translations[currentLanguage];
                    showMessage(t.welcomeMessage, 4000);
                }, 800);
            }, 600);
        }

        function updateInstructionsContent() {
            const t = translations[currentLanguage];
            document.getElementById('instructionsTitle').textContent = t.instructionsTitle;
            document.getElementById('instructionsContent').innerHTML = t.instructionsContent;
            
            // Update button text
            const button = document.querySelector('.instructions-btn');
            button.innerHTML = currentLanguage === 'en' ? 'â–¶ Play Game' : 'â–¶ Speel Spel';
        }

        function applyTranslations() {
            const t = translations[currentLanguage];
            const codes = commandCodes[currentLanguage];
            
            // Update game title
            document.querySelector('.game-area h1').innerHTML = `
                <span style="color: #006400; font-size: 20px;">${t.title1}</span><br>
                <span style="color: #FFD700; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); font-size: 32px; font-weight: bold;">${t.title2}</span><br>
                <span style="color: #006400; font-size: 20px;">${t.title3}</span>
            `;
            
            // Update button texts
            document.getElementById('turnLeft').innerHTML = t.turnLeft;
            document.getElementById('forward').innerHTML = t.forward;
            document.getElementById('jump').innerHTML = t.jump;
            document.getElementById('eat').innerHTML = t.eat;
            document.getElementById('turnRight').innerHTML = t.turnRight;
            document.getElementById('executeBtn').innerHTML = t.execute;
            document.getElementById('attemptAgainBtn').innerHTML = t.attemptAgain;
            document.getElementById('hintToggleLabel').innerHTML = t.hintToggle;
            document.getElementById('clearBtn').innerHTML = t.clear;
            document.getElementById('newGameBtn').innerHTML = t.newGame;
            document.getElementById('returnMenuBtn').innerHTML = t.returnMenu;
            
            // Update help button tooltip
            const helpBtn = document.querySelector('.help-button');
            if (helpBtn) {
                helpBtn.title = currentLanguage === 'en' ? 'Help' : 'Hulp';
            }
            
            // Update labels
            document.querySelector('.command-list-container h3').textContent = t.commandList;
            document.getElementById('positionLabel').textContent = t.position + ':';
            
            // Update Level Book label if it exists
            const levelBookLabel = document.getElementById('levelBookLabel');
            if (levelBookLabel) {
                levelBookLabel.textContent = t.levelBookLabel;
            }
            
            // Update level indicator text
            updateLevelIndicator();
            
            // Update instruction texts  
            const instructionDivs = document.querySelectorAll('.game-area > div[style], .command-area > div[style]');
            instructionDivs.forEach(div => {
                if (div.textContent.includes('click') || div.textContent.includes('kliek') || div.textContent.includes('Right')) {
                    div.textContent = t.rightClickRemove;
                } else if (div.textContent.includes('Keyboard') || div.textContent.includes('Sleutelbord')) {
                    div.textContent = t.keyboard;
                }
            });
            
            // Update position display
            updateToken();
            
            // Update command list to reflect language change
            updateCommandListDisplay();
        }

        const gridElement = document.getElementById('grid');
        
        // ===================================================================
        // SECTION 2: GRID CONFIGURATION AND GAME STATE VARIABLES
        // ===================================================================
        
        // Grid configurations for 5 difficulty levels
        // Each level defines: width (columns), height (rows), and obstacle counts
        // Level 1: 4Ã—3 grid - Tutorial level with no obstacles
        // Level 2: 4Ã—4 grid - Introduces walls
        // Level 3: 5Ã—5 grid - Adds traps and cats
        // Level 4: 7Ã—5 grid - More cheese and obstacles
        // Level 5: 9Ã—6 grid - Maximum challenge with multiple cats
        const gridConfigs = {
            1: { width: 4, height: 3, cheese: 1, traps: 0, walls: 0, cats: 0 },  // Tutorial
            2: { width: 4, height: 4, cheese: 1, traps: 0, walls: 1, cats: 0 },  // Beginner
            3: { width: 5, height: 5, cheese: 1, traps: 1, walls: 3, cats: 1 },  // Intermediate
            4: { width: 7, height: 5, cheese: 2, traps: 3, walls: 5, cats: 1 },  // Advanced
            5: { width: 9, height: 6, cheese: 3, traps: 5, walls: 5, cats: 2 }   // Expert
        };
        
        // Current game configuration
        let currentGridConfig = 4; // Default to level 4 (5Ã—7 advanced grid)
        let gridWidth = gridConfigs[currentGridConfig].width;    // Current grid columns
        let gridHeight = gridConfigs[currentGridConfig].height;  // Current grid rows
        let maxCheese = gridConfigs[currentGridConfig].cheese;   // Number of cheese to collect
        let maxTraps = gridConfigs[currentGridConfig].traps;     // Number of mouse traps
        let maxWalls = gridConfigs[currentGridConfig].walls;     // Number of wall obstacles
        let maxCats = gridConfigs[currentGridConfig].cats;       // Number of cats
        
        // Mouse (token) position and orientation
        let tokenRow = 0;      // Current row position (0-indexed)
        let tokenCol = 0;      // Current column position (0-indexed)
        let direction = 90;    // Mouse facing direction in degrees (0=up, 90=right, 180=down, 270=left)
        
        // Save initial state
        let initialRow = 0;
        let initialCol = 0;
        let initialDirection = 90;
        
        // Hint mode - shows L/R labels on mouse
        let hintMode = false;

        // ===================================================================
        // LEVEL BOOK SYSTEM
        // ===================================================================
        // Predefined challenge levels from "Manie and the 15 challenges"
        // Each level has exact placement of all game elements
        
        let isLevelBookMode = false;  // Track if playing Level Book mode
        let currentLevelBookLevel = 1; // Current level in Level Book (1-15)
        
        // Level Book data: 5x5 grid with 15 predefined levels
        // Legend: M=Manie, C=Cat, W=Wall, T=Trap, <=Cheese, empty=open space
        // initialDirection (optional): override auto-direction (0=up,90=right,180=down,270=left)
        const levelBook = {
            title: "Manie and the 15 challenges",
            gridSize: { width: 5, height: 5 },
            levels: {
                1: [
                    ['',  'W', '',  '',  ''],
                    ['M', '',  '',  '<', ''],
                    ['W', 'W', '',  '',  ''],
                    ['',  '',  'C', '',  'T'],
                    ['',  '',  '',  '',  '']
                ],
                2: [
                    ['',  '',  'M', '',  ''],
                    ['',  'T', '',  '',  '<'],
                    ['',  'W', 'W', 'W', ''],
                    ['',  '',  'C', '',  ''],
                    ['',  '',  '',  '',  '']
                ],
                3: [
                    ['',  '',  '',  '',  ''],
                    ['',  '',  '',  'C', ''],
                    ['W', 'W', '',  '',  ''],
                    ['',  '',  'T', '<', ''],
                    ['M', 'W', '',  '',  '']
                ],
                4: [
                    ['',  '',  '',  '<', ''],
                    ['',  'W', '',  '',  ''],
                    ['',  '',  'C', '',  'T'],
                    ['',  'W', '',  'W', ''],
                    ['',  '',  '',  '',  'M']
                ],
                5: [
                    ['',  '',  '',  '',  ''],
                    ['',  '',  'W', 'T', '<'],
                    ['C', '',  'M', '',  'W'],
                    ['',  '',  'W', '',  ''],
                    ['',  '',  '',  '',  '']
                ],
                6: [
                    ['C', '',  '<', '',  ''],
                    ['',  '',  'W', '',  ''],
                    ['T', '',  '',  '',  'T'],
                    ['',  'W', 'C', '',  ''],
                    ['',  '',  '',  'T', 'M']
                ],
                7: {
                    grid: [
                        ['',  'T', '',  'T', ''],
                        ['',  'W', '',  'W', ''],
                        ['',  'W', 'M', 'W', ''],
                        ['',  'W', 'W', 'W', '<'],
                        ['',  '',  'C', '',  '']
                    ],
                    initialDirection: 0  // Force mouse to face UP
                },
                8: [
                    ['C', '',  '',  'W', 'M'],
                    ['',  '',  '',  'W', ''],
                    ['<', '',  'C', '',  ''],
                    ['',  '',  '',  '',  'T'],
                    ['',  'T', '',  '',  '']
                ],
                9: [
                    ['',  '',  '',  'W', '<'],
                    ['',  'W', '',  'W', ''],
                    ['',  'W', 'T', 'W', ''],
                    ['',  'W', '',  'W', ''],
                    ['M', 'W', '',  '',  '']
                ],
                10: [
                    ['',  '',  'C', '',  '<'],
                    ['',  '',  'W', '',  ''],
                    ['M', 'T', '',  'T', '<'],
                    ['',  '',  'W', '',  ''],
                    ['',  '',  'C', '',  '<']
                ],
                11: [
                    ['M', '',  '<', '',  '<'],
                    ['',  '',  '',  '',  ''],
                    ['<', '',  'C', '',  '<'],
                    ['',  '',  '',  '',  ''],
                    ['<', '',  '<', '',  '<']
                ],
                12: [
                    ['M', 'W', '',  '',  ''],
                    ['',  '',  'W', '',  ''],
                    ['W', '',  '',  'W', ''],
                    ['',  'W', '',  '',  ''],
                    ['',  '',  'W', '',  '<']
                ],
                13: [
                    ['M', '<', '<', '<', '<'],
                    ['W', 'W', 'W', 'W', 'T'],
                    ['<', '<', '<', '<', '<'],
                    ['T', 'W', 'W', 'W', 'W'],
                    ['<', '<', '',  'C', '']
                ],
                14: [
                    ['',  '',  '',  'C', ''],
                    ['',  'W', '',  '',  ''],
                    ['<', 'T', '<', 'T', '<'],
                    ['',  '',  '',  'W', ''],
                    ['',  'C', '',  'W', 'M']
                ],
                15: [
                    ['<', '<', '<', '<', '<'],
                    ['<', 'W', 'W', 'W', '<'],
                    ['<', 'W', 'C', 'W', '<'],
                    ['<', 'W', 'W', 'W', '<'],
                    ['<', '<', '<', 'W', 'M']
                ]
            }
        };

        // Function to ensure direction doesn't point toward an edge
        function getValidDirection(row, col, currentGridWidth, currentGridHeight) {
            const validDirections = [];
            
            // Check each direction and add if it doesn't point toward edge
            if (row > 0) validDirections.push(0);   // Can face up if not at top
            if (col < currentGridWidth - 1) validDirections.push(90);  // Can face right if not at right edge
            if (row < currentGridHeight - 1) validDirections.push(180); // Can face down if not at bottom
            if (col > 0) validDirections.push(270); // Can face left if not at left edge
            
            // Return a random valid direction
            return validDirections[Math.floor(Math.random() * validDirections.length)];
        }

        // Function to get direction toward closest cheese
        function getDirectionToClosestCheese(mouseRow, mouseCol, cheeseArray) {
            if (cheeseArray.length === 0) {
                return 90; // Default to right if no cheese
            }
            
            // Find closest cheese using Manhattan distance
            let closestCheese = cheeseArray[0];
            let minDistance = Math.abs(mouseRow - closestCheese.row) + Math.abs(mouseCol - closestCheese.col);
            
            for (let i = 1; i < cheeseArray.length; i++) {
                const cheese = cheeseArray[i];
                const distance = Math.abs(mouseRow - cheese.row) + Math.abs(mouseCol - cheese.col);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestCheese = cheese;
                }
            }
            
            // Calculate direction to closest cheese
            const rowDiff = closestCheese.row - mouseRow;
            const colDiff = closestCheese.col - mouseCol;
            
            // Prioritize the larger difference (primary direction)
            if (Math.abs(rowDiff) > Math.abs(colDiff)) {
                // Vertical movement is primary
                return rowDiff > 0 ? 180 : 0; // Down or Up
            } else if (Math.abs(colDiff) > Math.abs(rowDiff)) {
                // Horizontal movement is primary
                return colDiff > 0 ? 90 : 270; // Right or Left
            } else if (rowDiff !== 0) {
                // Equal distance - prefer vertical
                return rowDiff > 0 ? 180 : 0; // Down or Up
            } else {
                // Equal distance - use horizontal
                return colDiff > 0 ? 90 : 270; // Right or Left
            }
        }

        // Create the grid
        function createGrid() {
            const grid = document.getElementById('grid');
            if (!grid) {
                console.error('Grid element not found!');
                return;
            }
            grid.innerHTML = '';
            for (let i = 0; i < gridWidth * gridHeight; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${i}`;
                grid.appendChild(cell);
            }
            
            // Store exact grid dimensions for screenshot cropping
            // Wait a brief moment for grid to render fully
            setTimeout(() => {
                const rect = grid.getBoundingClientRect();
                window.gridScreenshotBounds = {
                    width: rect.width,
                    height: rect.height
                };
            }, 100);
        }

        function selectGridSize(configId) {
            currentGridConfig = configId;
            gridWidth = gridConfigs[configId].width;
            gridHeight = gridConfigs[configId].height;
            maxCheese = gridConfigs[configId].cheese;
            maxTraps = gridConfigs[configId].traps;
            maxWalls = gridConfigs[configId].walls;
            maxCats = gridConfigs[configId].cats;
            
            // Update grid CSS
            gridElement.style.gridTemplateColumns = `repeat(${gridWidth}, 60px)`;
            gridElement.style.gridTemplateRows = `repeat(${gridHeight}, 60px)`;
            
            // Set starting position away from edges (at least 1 cell from any edge)
            tokenRow = Math.floor(gridHeight / 3); // Not at top or bottom
            tokenCol = Math.floor(gridWidth / 3);  // Not at left or right
            
            // Ensure direction doesn't point toward edge if at border
            direction = getValidDirection(tokenRow, tokenCol, gridWidth, gridHeight);
            
            // Save as initial state
            initialRow = tokenRow;
            initialCol = tokenCol;
            initialDirection = direction;
            
            clearCommands();
            createGrid();
            placeRandomCheese();
            updateToken();
            updateCommandListDisplay();
            
            // Reset repeat counts
            resetRepeatCounts();
        }

        // ===================================================================
        // LEVEL BOOK FUNCTIONS
        // ===================================================================
        
        // Load a specific level from the Level Book
        function loadLevelFromBook(levelNum, preserveCommands = false) {
            console.log(`Loading Level Book level ${levelNum}, isLevelBookMode=${isLevelBookMode}, preserveCommands=${preserveCommands}`);
            
            if (!levelBook.levels[levelNum]) {
                console.error(`Level ${levelNum} not found in Level Book`);
                return;
            }
            
            // Set grid size to Level Book size (5x5)
            gridWidth = levelBook.gridSize.width;
            gridHeight = levelBook.gridSize.height;
            
            console.log(`Grid size set to ${gridWidth}x${gridHeight}`);
            
            // Update grid CSS
            gridElement.style.gridTemplateColumns = `repeat(${gridWidth}, 60px)`;
            gridElement.style.gridTemplateRows = `repeat(${gridHeight}, 60px)`;
            
            // Clear previous game state (optionally preserve commands)
            if (!preserveCommands) {
                clearCommands();
            }
            createGrid();
            
            // Get level data (handle both array format and object format with direction override)
            const rawLevel = levelBook.levels[levelNum];
            const levelData = Array.isArray(rawLevel) ? rawLevel : rawLevel.grid;
            const directionOverride = Array.isArray(rawLevel) ? null : rawLevel.initialDirection;
            
            // Arrays to store positions
            cheesePositions = [];
            trapPositions = [];
            wallPositions = [];
            catPositions = [];
            
            // Parse level data and place elements
            for (let row = 0; row < gridHeight; row++) {
                for (let col = 0; col < gridWidth; col++) {
                    const cell = levelData[row][col];
                    
                    switch(cell) {
                        case 'M': // Manie starting position
                            tokenRow = row;
                            tokenCol = col;
                            console.log(`Manie at (${row}, ${col})`);
                            break;
                        case '<': // Cheese
                            cheesePositions.push({row, col});
                            console.log(`Cheese at (${row}, ${col})`);
                            break;
                        case 'T': // Trap
                            trapPositions.push({row, col});
                            console.log(`Trap at (${row}, ${col})`);
                            break;
                        case 'W': // Wall
                            wallPositions.push({row, col});
                            console.log(`Wall at (${row}, ${col})`);
                            break;
                        case 'C': // Cat
                            catPositions.push({row, col});
                            console.log(`Cat at (${row}, ${col})`);
                            break;
                    }
                }
            }
            
            console.log(`Total elements: ${cheesePositions.length} cheese, ${trapPositions.length} traps, ${wallPositions.length} walls, ${catPositions.length} cats`);
            
            // Set direction: use override if specified, otherwise face closest cheese
            if (directionOverride !== null) {
                direction = directionOverride;
                console.log(`Mouse direction overridden to ${direction}Â°`);
            } else if (cheesePositions.length > 0) {
                direction = getDirectionToClosestCheese(tokenRow, tokenCol, cheesePositions);
                console.log(`Mouse facing closest cheese at ${direction}Â°`);
            } else {
                direction = getValidDirection(tokenRow, tokenCol, gridWidth, gridHeight);
                console.log(`No cheese, mouse facing ${direction}Â°`);
            }
            
            // Save initial state
            initialRow = tokenRow;
            initialCol = tokenCol;
            initialDirection = direction;
            
            // Save starting cheese positions for attemptAgain/executeCommands
            startingCheesePositions = JSON.parse(JSON.stringify(cheesePositions));
            eatenCheese = [];
            
            // Update displays - use correct function names
            updateCheeseDisplay();
            updateTrapDisplay();
            updateWallDisplay();
            updateCatDisplay();
            updateToken();
            updateCommandListDisplay();
            updateLevelIndicator();
            
            console.log('Level loaded and displayed');
            
            // Reset repeat counts
            resetRepeatCounts();
        }
        
        // Update the level indicator display
        function updateLevelIndicator() {
            const levelIndicator = document.getElementById('levelIndicator');
            const levelIndicatorText = document.getElementById('levelIndicatorText');
            
            // Safety check - make sure elements exist
            if (!levelIndicator || !levelIndicatorText) {
                console.warn('Level indicator elements not found');
                return;
            }
            
            if (isLevelBookMode) {
                // Show level indicator in Level Book mode
                levelIndicator.style.display = 'block';
                if (currentLanguage === 'en') {
                    levelIndicatorText.textContent = `ðŸ“š Level ${currentLevelBookLevel} of 15`;
                } else {
                    levelIndicatorText.textContent = `ðŸ“š Vlak ${currentLevelBookLevel} van 15`;
                }
            } else {
                // Hide level indicator in random mode
                levelIndicator.style.display = 'none';
            }
        }

        createGrid();

        // Command list management
        let commandList = []; // Each item: {cmd: 'F', count: 2}
        
        // Repeat counts for each command button
        let repeatCounts = {
            L: 1,
            F: 1,
            J: 1,
            R: 1,
            E: 1
        };

        function resetRepeatCounts() {
            repeatCounts = { L: 1, F: 1, J: 1, R: 1, E: 1 };
            document.getElementById('repeat-L').textContent = '1';
            document.getElementById('repeat-F').textContent = '1';
            document.getElementById('repeat-J').textContent = '1';
            document.getElementById('repeat-R').textContent = '1';
            document.getElementById('repeat-E').textContent = '1';
        }

        function addCommand(commandType) {
            const codes = commandCodes[currentLanguage];
            let command = '';
            
            switch(commandType) {
                case 'L': command = 'L'; break;
                case 'F': command = codes.forward; break;
                case 'J': command = codes.jump; break;
                case 'R': command = 'R'; break;
                case 'E': command = 'E'; break;
            }
            
            // Get repeat count for this command type
            const count = repeatCounts[commandType] || 1;
            
            commandList.push({ cmd: command, count: count });
            updateCommandListDisplay();
            
            // Reset all repeat counts to 1 after adding command
            resetRepeatCounts();
        }

        function changeRepeat(commandType, delta) {
            repeatCounts[commandType] = Math.max(1, Math.min(9, repeatCounts[commandType] + delta));
            document.getElementById(`repeat-${commandType}`).textContent = repeatCounts[commandType];
        }

        function clearCommands() {
            commandList = [];
            updateCommandListDisplay();
        }

        function updateCommandListDisplay() {
            const listElement = document.getElementById('commandList');
            listElement.innerHTML = '';
            
            const t = translations[currentLanguage];
            
            // Add START command (not deletable)
            const startItem = document.createElement('div');
            startItem.className = 'command-item';
            startItem.style.background = '#ffebee';
            startItem.style.borderLeft = '4px solid #e53935';
            startItem.style.fontWeight = 'bold';
            startItem.innerHTML = `<span class="command-name">${t.start}</span>`;
            startItem.title = 'START - Cannot be removed';
            listElement.appendChild(startItem);
            
            // Add user commands (indented)
            commandList.forEach((cmdObj, index) => {
                const item = document.createElement('div');
                item.className = 'command-item';
                item.setAttribute('data-index', index);
                item.style.marginLeft = '20px'; // Indent
                
                // Get command name based on current language
                let commandName = t.commands[cmdObj.cmd] || cmdObj.cmd;
                let multiplierHTML = '';
                
                // Show multiplier if count > 1
                if (cmdObj.count > 1) {
                    multiplierHTML = ` <span class="multiplier">âœ– ${cmdObj.count}</span>`;
                }
                
                item.innerHTML = `
                    <span class="command-code">${cmdObj.cmd}</span>
                    <span class="command-name">${commandName}${multiplierHTML}</span>
                `;
                
                // Add click to highlight, second click to remove
                item.addEventListener('click', () => {
                    if (item.classList.contains('highlighted')) {
                        removeCommand(index);
                    } else {
                        // Remove highlight from any other item first
                        document.querySelectorAll('.command-item.highlighted').forEach(el => el.classList.remove('highlighted'));
                        item.classList.add('highlighted');
                    }
                });
                
                // Keep right-click to remove as well
                item.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    removeCommand(index);
                });
                
                // Add hover effect hint
                item.title = 'Click to select, click again to remove';
                
                listElement.appendChild(item);
            });
            
            // Add STOP command (not deletable)
            const stopItem = document.createElement('div');
            stopItem.className = 'command-item';
            stopItem.style.background = '#e8f5e9';
            stopItem.style.borderLeft = '4px solid #43a047';
            stopItem.style.fontWeight = 'bold';
            stopItem.innerHTML = `<span class="command-name">${t.stop}</span>`;
            stopItem.title = 'STOP - Cannot be removed';
            listElement.appendChild(stopItem);
        }

        function removeCommand(index) {
            commandList.splice(index, 1);
            updateCommandListDisplay();
        }

        // Cheese management
        let cheesePositions = [];
        let startingCheesePositions = [];
        let eatenCheese = [];

        // Trap management
        let trapPositions = [];
        
        // Wall management
        let wallPositions = [];
        
        // Cat management
        let catPositions = [];

        function isAdjacentToCat(row, col) {
            // Check if a position is on or adjacent to any cat (8 directions)
            return catPositions.some(cat => {
                const rowDiff = Math.abs(cat.row - row);
                const colDiff = Math.abs(cat.col - col);
                // Adjacent includes diagonal (max difference of 1 in both directions)
                // Also includes the cat's own position (both differences = 0)
                return rowDiff <= 1 && colDiff <= 1;
            });
        }

        function hasValidPathToCheese() {
            // BFS to check if there's a path from mouse to ALL cheese pieces
            // Path must avoid: walls, cat danger zones, and traps (mouse can't walk through or jump over traps)
            
            // First, build a set of all reachable cells from mouse position
            const reachableCells = new Set();
            const queue = [[tokenRow, tokenCol]];
            reachableCells.add(`${tokenRow},${tokenCol}`);
            
            while (queue.length > 0) {
                const [currentRow, currentCol] = queue.shift();
                
                // Try all 4 directions (not diagonal)
                const directions = [
                    [-1, 0], // Up
                    [1, 0],  // Down
                    [0, -1], // Left
                    [0, 1]   // Right
                ];
                
                for (let [dr, dc] of directions) {
                    const newRow = currentRow + dr;
                    const newCol = currentCol + dc;
                    const key = `${newRow},${newCol}`;
                    
                    // Check if valid position and not already visited
                    if (newRow >= 0 && newRow < gridHeight && 
                        newCol >= 0 && newCol < gridWidth && 
                        !reachableCells.has(key)) {
                        
                        // Check if safe to walk (not wall, not cat danger zone, not trap)
                        const hasWall = wallPositions.some(w => w.row === newRow && w.col === newCol);
                        const hasTrap = trapPositions.some(t => t.row === newRow && t.col === newCol);
                        const nearCat = isAdjacentToCat(newRow, newCol);
                        
                        if (!hasWall && !hasTrap && !nearCat) {
                            reachableCells.add(key);
                            queue.push([newRow, newCol]);
                        }
                    }
                }
            }
            
            // Now check if ALL cheese pieces are reachable
            for (let cheese of cheesePositions) {
                const cheeseKey = `${cheese.row},${cheese.col}`;
                if (!reachableCells.has(cheeseKey)) {
                    return false; // This cheese is not reachable
                }
            }
            
            return true; // All cheese is reachable
        }

        function triggerCatAttack() {
            // Find which cat's danger zone the mouse entered (nearest cat)
            let attackingCatIndex = -1;
            let minDistance = Infinity;
            
            catPositions.forEach((cat, index) => {
                // Check if mouse is in this cat's danger zone (within 1 cell)
                const rowDiff = Math.abs(tokenRow - cat.row);
                const colDiff = Math.abs(tokenCol - cat.col);
                
                if (rowDiff <= 1 && colDiff <= 1) {
                    // Mouse is in this cat's danger zone
                    const distance = Math.sqrt(rowDiff * rowDiff + colDiff * colDiff);
                    if (distance < minDistance) {
                        minDistance = distance;
                        attackingCatIndex = index;
                    }
                }
            });
            
            // Only the nearest cat attacks
            if (attackingCatIndex >= 0) {
                const cat = catPositions[attackingCatIndex];
                // Find the cat element with matching data-cat-index
                const catElement = document.querySelector(`.cat[data-cat-index="${attackingCatIndex}"]`);
                
                if (catElement) {
                    // Calculate direction from cat to mouse
                    const rowDiff = tokenRow - cat.row;
                    const colDiff = tokenCol - cat.col;
                    
                    // Calculate angle to mouse (in degrees)
                    // NOTE: Cat is drawn facing RIGHT (0Â° = east direction)
                    const angleRad = Math.atan2(rowDiff, colDiff);
                    let angleDeg = angleRad * (180 / Math.PI);
                    
                    // Determine if we need to flip the cat horizontally
                    // If mouse is on the left side (angle > 90Â° or < -90Â°), flip the cat
                    let flipScale = 1; // 1 = normal, -1 = flipped
                    let adjustedAngle = angleDeg;
                    
                    if (angleDeg > 90 || angleDeg < -90) {
                        // Mouse is on the left side - flip the cat
                        flipScale = -1;
                        // Adjust angle for flipped orientation
                        // When flipped, we need to mirror the angle
                        if (angleDeg > 90) {
                            adjustedAngle = 180 - angleDeg; // e.g., 135Â° becomes 45Â°
                        } else {
                            adjustedAngle = -180 - angleDeg; // e.g., -135Â° becomes -45Â°
                        }
                    }
                    
                    // Clamp rotation to prevent extreme angles (max Â±75Â° for natural look)
                    adjustedAngle = Math.max(-75, Math.min(75, adjustedAngle));
                    
                    // Calculate movement to mouse's BLOCK (each cell is 60px)
                    // Cat needs to move to the center of mouse's cell
                    const cellSize = 60; // pixels per cell
                    const moveX = colDiff * cellSize; // Horizontal distance in pixels
                    const moveY = rowDiff * cellSize; // Vertical distance in pixels
                    
                    // Cat's original rotation is always 0Â° (facing right)
                    catElement.style.setProperty('--original-rotation', '0deg');
                    catElement.style.setProperty('--original-flip', '1');
                    
                    // Set CSS custom properties for attack
                    catElement.style.setProperty('--attack-x', `calc(-50% + ${moveX}px)`);
                    catElement.style.setProperty('--attack-y', `calc(-50% + ${moveY}px)`);
                    catElement.style.setProperty('--attack-rotation', `${adjustedAngle}deg`);
                    catElement.style.setProperty('--attack-flip', `${flipScale}`);
                    
                    catElement.classList.add('attacking');
                    
                    // Bring the cat's cell to the front during attack
                    const catCell = catElement.closest('.cell');
                    if (catCell) {
                        catCell.style.zIndex = '100';
                    }
                    
                    // Remove class after animation completes (1.6s)
                    setTimeout(() => {
                        catElement.classList.remove('attacking');
                        // Reset cell z-index
                        if (catCell) {
                            catCell.style.zIndex = '';
                        }
                    }, 1600);
                }
            }
            
            // Show caught message AFTER animation completes + short delay
            // Total: 1600ms (animation) + 200ms (delay) = 1800ms
            setTimeout(() => {
                const t = translations[currentLanguage];
                showMessage(t.catCaught, 2500, false, true); // No emoticons, special cat styling
            }, 1800);
            
            // Auto-reset after full sequence: animation (1600ms) + delay (200ms) + message (2500ms) = 4300ms
            setTimeout(() => {
                attemptAgain();
            }, 4300);
            
            return true; // Caught by cat
        }

        function placeRandomCheese() {
            cheesePositions = [];
            trapPositions = [];
            wallPositions = [];
            catPositions = [];
            const occupiedCells = new Set();
            
            // Don't place anything on starting position
            let mouseRow = tokenRow;
            let mouseCol = tokenCol;
            const startCellIndex = mouseRow * gridWidth + mouseCol;
            occupiedCells.add(startCellIndex);
            
            // Place cats FIRST based on current grid configuration
            let catAttempts = 0;
            while (catPositions.length < maxCats && catAttempts < 100) {
                catAttempts++;
                const row = Math.floor(Math.random() * gridHeight);
                const col = Math.floor(Math.random() * gridWidth);
                const cellIndex = row * gridWidth + col;
                
                if (!occupiedCells.has(cellIndex)) {
                    catPositions.push({ row, col });
                    occupiedCells.add(cellIndex);
                }
            }
            
            // Check if mouse starting position is too close to any cat
            // If so, move the mouse to a safe position
            if (isAdjacentToCat(mouseRow, mouseCol)) {
                // Find a new safe position for the mouse
                let safePositionFound = false;
                for (let attempts = 0; attempts < 100 && !safePositionFound; attempts++) {
                    const newRow = Math.floor(Math.random() * gridHeight);
                    const newCol = Math.floor(Math.random() * gridWidth);
                    const newCellIndex = newRow * gridWidth + newCol;
                    
                    // Position must not be occupied AND not adjacent to cat
                    if (!occupiedCells.has(newCellIndex) && !isAdjacentToCat(newRow, newCol)) {
                        // Update occupied cells - keep old position blocked, add new position
                        occupiedCells.add(newCellIndex);
                        
                        mouseRow = newRow;
                        mouseCol = newCol;
                        tokenRow = newRow;
                        tokenCol = newCol;
                        
                        // Get valid direction for new position
                        direction = getValidDirection(tokenRow, tokenCol, gridWidth, gridHeight);
                        
                        safePositionFound = true;
                    }
                }
            }
            
            // ALWAYS set initial positions after potential relocation
            // This ensures attemptAgain() returns to the correct starting position
            initialRow = tokenRow;
            initialCol = tokenCol;
            initialDirection = direction;
            
            // Block all cells adjacent to cats (8 directions) so cheese can't be placed there
            catPositions.forEach(cat => {
                const adjacentOffsets = [
                    [-1, -1], [-1, 0], [-1, 1],  // Top row
                    [0, -1],           [0, 1],   // Middle row (left and right)
                    [1, -1],  [1, 0],  [1, 1]    // Bottom row
                ];
                
                adjacentOffsets.forEach(([rowOffset, colOffset]) => {
                    const adjRow = cat.row + rowOffset;
                    const adjCol = cat.col + colOffset;
                    
                    // Check if adjacent cell is within grid bounds
                    if (adjRow >= 0 && adjRow < gridHeight && adjCol >= 0 && adjCol < gridWidth) {
                        const adjCellIndex = adjRow * gridWidth + adjCol;
                        occupiedCells.add(adjCellIndex);
                    }
                });
            });
            
            // IMPORTANT: Make sure mouse position is still marked as occupied
            // This prevents cheese from being placed on the mouse
            const currentMouseCellIndex = mouseRow * gridWidth + mouseCol;
            occupiedCells.add(currentMouseCellIndex);
            
            // Place cheese based on current grid configuration (avoiding all occupied cells)
            let cheeseAttempts = 0;
            while (cheesePositions.length < maxCheese && cheeseAttempts < 100) {
                cheeseAttempts++;
                const row = Math.floor(Math.random() * gridHeight);
                const col = Math.floor(Math.random() * gridWidth);
                const cellIndex = row * gridWidth + col;
                
                // Double-check: not occupied AND not mouse position
                if (!occupiedCells.has(cellIndex) && !(row === mouseRow && col === mouseCol)) {
                    cheesePositions.push({ row, col });
                    occupiedCells.add(cellIndex);
                }
            }
            
            // Place traps based on current grid configuration
            // Traps should not completely block access to cheese
            let trapAttempts = 0;
            while (trapPositions.length < maxTraps && trapAttempts < 100) {
                trapAttempts++;
                const row = Math.floor(Math.random() * gridHeight);
                const col = Math.floor(Math.random() * gridWidth);
                const cellIndex = row * gridWidth + col;
                
                if (!occupiedCells.has(cellIndex)) {
                    trapPositions.push({ row, col });
                    occupiedCells.add(cellIndex);
                }
            }
            
            // Place walls based on current grid configuration
            let wallAttempts = 0;
            while (wallPositions.length < maxWalls && wallAttempts < 100) {
                wallAttempts++;
                const row = Math.floor(Math.random() * gridHeight);
                const col = Math.floor(Math.random() * gridWidth);
                const cellIndex = row * gridWidth + col;
                
                if (!occupiedCells.has(cellIndex)) {
                    wallPositions.push({ row, col });
                    occupiedCells.add(cellIndex);
                }
            }
            
            // Verify there's a valid path from mouse to ALL cheese
            // Path must avoid: walls, traps, and cat danger zones
            // If not, retry with new random positions (up to 30 attempts)
            if (maxCheese > 0 && (maxCats > 0 || maxTraps > 0 || maxWalls > 0)) {
                if (!hasValidPathToCheese()) {
                    // No valid path found - retry placement
                    if (!this.placementAttempts) {
                        this.placementAttempts = 0;
                    }
                    this.placementAttempts++;
                    
                    if (this.placementAttempts < 30) {
                        // Try again with new random positions
                        placeRandomCheese();
                        return;
                    } else {
                        // After 30 attempts, reset counter and continue anyway
                        // This prevents infinite loops on impossible configurations
                        console.warn('Could not find valid path after 20 attempts');
                        this.placementAttempts = 0;
                    }
                } else {
                    // Valid path found - reset counter
                    this.placementAttempts = 0;
                }
            }
            
            // Save starting positions
            startingCheesePositions = JSON.parse(JSON.stringify(cheesePositions));
            eatenCheese = [];
            
            updateCheeseDisplay();
            updateTrapDisplay();
            updateWallDisplay();
            updateCatDisplay();
        }

        function updateCheeseDisplay() {
            // Remove all existing cheese
            document.querySelectorAll('.cheese').forEach(cheese => cheese.remove());
            
            // Add cheese to grid
            cheesePositions.forEach(pos => {
                const cellIndex = pos.row * gridWidth + pos.col;
                const cell = document.getElementById(`cell-${cellIndex}`);
                const cheese = document.createElement('div');
                cheese.className = 'cheese';
                cheese.textContent = 'ðŸ§€';
                cell.appendChild(cheese);
            });
        }

        function updateTrapDisplay() {
            // Remove all existing traps
            document.querySelectorAll('.trap').forEach(trap => trap.remove());
            
            // Add traps to grid
            trapPositions.forEach(pos => {
                const cellIndex = pos.row * gridWidth + pos.col;
                const cell = document.getElementById(`cell-${cellIndex}`);
                const trap = document.createElement('div');
                trap.className = 'trap';
                trap.textContent = 'ðŸª¤';
                cell.appendChild(trap);
            });
        }

        function updateWallDisplay() {
            // Remove all existing walls
            document.querySelectorAll('.wall').forEach(wall => wall.remove());
            
            // Add walls to grid
            wallPositions.forEach(pos => {
                const cellIndex = pos.row * gridWidth + pos.col;
                const cell = document.getElementById(`cell-${cellIndex}`);
                const wall = document.createElement('div');
                wall.className = 'wall';
                wall.textContent = 'ðŸ§±';
                cell.appendChild(wall);
            });
        }

        function updateCatDisplay() {
            // Remove all existing cats
            document.querySelectorAll('.cat').forEach(cat => cat.remove());
            
            // Add cats to grid
            catPositions.forEach((pos, index) => {
                const cellIndex = pos.row * gridWidth + pos.col;
                const cell = document.getElementById(`cell-${cellIndex}`);
                const catContainer = document.createElement('div');
                catContainer.className = 'cat';
                catContainer.setAttribute('data-cat-index', index);
                
                // Create SVG cat
                catContainer.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 260 240" width="100%" height="100%">
                        <path d="M205 145 q45 10 25 45 q-5 18 -30 10" fill="none" stroke="#d97a1f" stroke-width="14" stroke-linecap="round">
                            <animateTransform attributeName="transform" attributeType="XML" type="rotate" 
                                values="0 205 145; -15 205 145; 0 205 145; 15 205 145; 0 205 145"
                                keyTimes="0; 0.25; 0.5; 0.75; 1" dur="1.2s" repeatCount="indefinite"/>
                        </path>
                        <ellipse cx="135" cy="155" rx="75" ry="40" fill="#f39c3d"/>
                        <path d="M90 145 q20 -15 40 0" stroke="#ffd24d" stroke-width="7" fill="none"/>
                        <path d="M105 165 q20 -15 40 0" stroke="#ffd24d" stroke-width="7" fill="none"/>
                        <path d="M120 185 q20 -15 40 0" stroke="#ffd24d" stroke-width="7" fill="none"/>
                        <circle cx="120" cy="90" r="45" fill="#f6b15a"/>
                        <g>
                            <path d="M80 55 L60 25 L95 40 Z" fill="#f6b15a">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 80 55; -4 80 55; 0 80 55; 3 80 55; 0 80 55"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2.5s" repeatCount="indefinite"/>
                            </path>
                            <path d="M78 52 L70 35 L92 42 Z" fill="#f9c99a">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 80 55; -4 80 55; 0 80 55; 3 80 55; 0 80 55"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2.5s" repeatCount="indefinite"/>
                            </path>
                        </g>
                        <g>
                            <path d="M160 55 L180 25 L145 40 Z" fill="#f6b15a">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 160 55; 4 160 55; 0 160 55; -3 160 55; 0 160 55"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2.5s" repeatCount="indefinite"/>
                            </path>
                            <path d="M162 52 L170 35 L148 42 Z" fill="#f9c99a">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 160 55; 4 160 55; 0 160 55; -3 160 55; 0 160 55"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2.5s" repeatCount="indefinite"/>
                            </path>
                        </g>
                        <ellipse cx="105" cy="88" rx="13" ry="18" fill="#fff"/>
                        <ellipse cx="135" cy="88" rx="13" ry="18" fill="#fff"/>
                        <ellipse cx="105" cy="92" rx="7" ry="11" fill="#3a7f5c"/>
                        <ellipse cx="135" cy="92" rx="7" ry="11" fill="#3a7f5c"/>
                        <ellipse cx="105" cy="95" rx="3" ry="8" fill="#000"/>
                        <ellipse cx="135" cy="95" rx="3" ry="8" fill="#000"/>
                        <circle cx="102" cy="84" r="3" fill="#fff"/>
                        <circle cx="132" cy="84" r="3" fill="#fff"/>
                        <path d="M88 70 q16 -12 32 -4" stroke="#7a1e2c" stroke-width="3" fill="none"/>
                        <path d="M122 66 q20 -2 34 10" stroke="#7a1e2c" stroke-width="3" fill="none"/>
                        <polygon points="120,98 114,105 126,105" fill="#e56"/>
                        <path d="M106 116 q10 6 20 -2 q6 -2 10 -6" stroke="#222" stroke-width="3" fill="none"/>
                        <g>
                            <path d="M78 92 l-28 -6" stroke="#333" stroke-width="2">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 78 92; -5 78 92; 0 78 92; 3 78 92; 0 78 92"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2s" repeatCount="indefinite"/>
                            </path>
                            <path d="M76 102 l-30 0" stroke="#333" stroke-width="2">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 76 102; -4 76 102; 0 76 102; 4 76 102; 0 76 102"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2.2s" repeatCount="indefinite"/>
                            </path>
                            <path d="M78 112 l-28 6" stroke="#333" stroke-width="2">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 78 112; -6 78 112; 0 78 112; 2 78 112; 0 78 112"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="1.8s" repeatCount="indefinite"/>
                            </path>
                        </g>
                        <g>
                            <path d="M162 92 l28 -6" stroke="#333" stroke-width="2">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 162 92; 5 162 92; 0 162 92; -3 162 92; 0 162 92"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2s" repeatCount="indefinite"/>
                            </path>
                            <path d="M164 102 l30 0" stroke="#333" stroke-width="2">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 164 102; 4 164 102; 0 164 102; -4 164 102; 0 164 102"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="2.2s" repeatCount="indefinite"/>
                            </path>
                            <path d="M162 112 l28 6" stroke="#333" stroke-width="2">
                                <animateTransform attributeName="transform" attributeType="XML" type="rotate"
                                    values="0 162 112; 6 162 112; 0 162 112; -2 162 112; 0 162 112"
                                    keyTimes="0; 0.3; 0.5; 0.7; 1" dur="1.8s" repeatCount="indefinite"/>
                            </path>
                        </g>
                        <ellipse cx="175" cy="182" rx="14" ry="9" fill="#c97a2a"/>
                        <ellipse cx="195" cy="180" rx="13" ry="8" fill="#c97a2a"/>
                        <path d="M170 188 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M176 188 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M182 188 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M190 186 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M196 186 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M202 186 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <ellipse cx="95" cy="185" rx="15" ry="10" fill="#f5c285"/>
                        <ellipse cx="115" cy="187" rx="14" ry="9" fill="#f5c285"/>
                        <path d="M88 192 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M95 193 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M102 192 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M108 194 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M115 195 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M122 194 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
                    </svg>
                `;
                
                cell.appendChild(catContainer);
            });
        }

        function checkForTrap(duringExecution = false) {
            const onTrap = trapPositions.some(
                pos => pos.row === tokenRow && pos.col === tokenCol
            );
            
            if (onTrap && translations[currentLanguage]) {
                const t = translations[currentLanguage];
                showMessage(t.gameOver, 2500, false); // No celebration animations for trap
                
                // Only auto-reset if not during execution
                if (!duringExecution) {
                    setTimeout(() => {
                        attemptAgain();
                    }, 2500);
                }
                
                return true;
            }
            return false;
        }

        function checkForWallAtPosition(row, col) {
            return wallPositions.some(
                pos => pos.row === row && pos.col === col
            );
        }

        function checkForTrapAtPosition(row, col) {
            return trapPositions.some(
                pos => pos.row === row && pos.col === col
            );
        }

        function showWallError() {
            const t = translations[currentLanguage];
            showMessage(t.wallHit, 2500);
        }

        function showTrapJumpError() {
            const t = translations[currentLanguage];
            showMessage(t.trapJump, 2500);
        }

        function eatCheese() {
            const cheeseIndex = cheesePositions.findIndex(
                pos => pos.row === tokenRow && pos.col === tokenCol
            );
            
            if (cheeseIndex !== -1) {
                // Track eaten cheese
                const eatenPos = cheesePositions[cheeseIndex];
                eatenCheese.push({ row: eatenPos.row, col: eatenPos.col });
                
                // Remove cheese
                cheesePositions.splice(cheeseIndex, 1);
                updateCheeseDisplay();
                if (translations[currentLanguage]) {
                    const t = translations[currentLanguage];
                    showMessage(t.njomNjom);
                }
                return true;
            }
            return false;
        }

        function showMessage(text, duration = 1000, isCelebration = false, isCatCaught = false) {
            const overlay = document.getElementById('messageOverlay');
            overlay.textContent = text;
            
            // Add appropriate class
            let className = 'message-overlay';
            if (isCelebration) {
                className += ' celebration';
            } else if (isCatCaught) {
                className += ' cat-caught';
            }
            overlay.className = className;
            overlay.style.display = 'block';
            
            // Add floating emoticons for celebration only
            if (isCelebration) {
                const emoticons = ['ðŸŽ‰', 'â­', 'ðŸ§€', 'âœ¨', 'ðŸŽŠ', 'ðŸ’«', 'ðŸ†', 'ðŸ‘'];
                const positions = [
                    { left: '20%', top: '30%' },
                    { left: '80%', top: '30%' },
                    { left: '15%', top: '60%' },
                    { left: '85%', top: '60%' },
                    { left: '30%', top: '20%' },
                    { left: '70%', top: '20%' },
                    { left: '25%', top: '70%' },
                    { left: '75%', top: '70%' }
                ];
                
                const emoticonElements = [];
                
                emoticons.forEach((emoji, index) => {
                    setTimeout(() => {
                        const emoticon = document.createElement('div');
                        emoticon.className = 'celebration-emoticon';
                        emoticon.textContent = emoji;
                        emoticon.style.left = positions[index].left;
                        emoticon.style.top = positions[index].top;
                        document.body.appendChild(emoticon);
                        emoticonElements.push(emoticon);
                        
                        // Remove after animation
                        setTimeout(() => {
                            emoticon.remove();
                        }, 2000);
                    }, index * 150); // Stagger the appearance
                });
            }
            
            setTimeout(() => {
                overlay.style.display = 'none';
                overlay.className = 'message-overlay';
            }, duration);
        }

        function newGame() {
            // Clear commands first
            clearCommands();
            
            // Handle Level Book mode vs Random mode
            if (isLevelBookMode) {
                // Reload current level
                loadLevelFromBook(currentLevelBookLevel);
            } else {
                // Place new cheese and obstacles (random mode)
                // NOTE: placeRandomCheese() handles setting initialRow/initialCol/initialDirection
                // if the mouse needs to be relocated due to cat proximity
                placeRandomCheese();
                
                // Update display
                updateToken();
                
                // Reset repeat counts
                resetRepeatCounts();
            }
            
            // Show welcome message
            const t = translations[currentLanguage];
            showMessage(t.welcomeMessage, 4000);
        }

        function attemptAgain() {
            if (isLevelBookMode) {
                // In Level Book mode, reload the entire level but KEEP the commands
                loadLevelFromBook(currentLevelBookLevel, true); // true = preserveCommands
            } else {
                // In random mode, just reset position and restore cheese
                // Reset position to initial state
                tokenRow = initialRow;
                tokenCol = initialCol;
                direction = initialDirection;
                
                // Restore all eaten cheese
                cheesePositions = JSON.parse(JSON.stringify(startingCheesePositions));
                eatenCheese = [];
                
                // Update display
                updateCheeseDisplay();
                updateToken();
            }
        }

        function returnToMenu() {
            // Hide game container
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.classList.remove('visible');
            
            // Clear all game state
            clearCommands();
            cheesePositions = [];
            trapPositions = [];
            wallPositions = [];
            catPositions = [];
            
            // Reset to default values
            isLevelBookMode = false;
            currentLevelBookLevel = 1;
            
            // Show splash screen after short delay
            setTimeout(() => {
                const splashScreen = document.getElementById('splashScreen');
                splashScreen.classList.remove('hidden');
                gameContainer.style.opacity = '0';
            }, 300);
        }

        // Place the token initially
        function updateToken(skipTrapCheck = false, moveDirection = null) {
            // Remove token from all cells
            document.querySelectorAll('.token').forEach(token => token.remove());
            
            // Add token to current position
            const cellIndex = tokenRow * gridWidth + tokenCol;
            const cell = document.getElementById(`cell-${cellIndex}`);
            const token = document.createElement('div');
            token.className = 'token';
            
            // Add movement animation class if direction provided
            if (moveDirection) {
                // Check if it's a jump animation (starts with 'jump-')
                if (moveDirection.startsWith('jump-')) {
                    token.classList.add(moveDirection);
                } else {
                    token.classList.add(`move-${moveDirection}`);
                }
            }
            
            // Create SVG for top-down mouse view with rotation
            // Add L/R labels if hint mode is active
            const hintLabels = hintMode ? `
                <!-- LEFT LABEL - LARGER Yellow square background -->
                <rect x="2" y="39" width="26" height="26" 
                      fill="#FFD700" 
                      stroke="#800000" 
                      stroke-width="2" 
                      rx="3"/>
                
                <!-- LEFT LABEL - LARGER Bold L -->
                <text x="15" y="54" 
                      font-family="Arial, sans-serif" 
                      font-size="24" 
                      font-weight="900" 
                      fill="#FF0000" 
                      stroke="#FFFFFF" 
                      stroke-width="1"
                      paint-order="stroke"
                      text-anchor="middle"
                      dominant-baseline="middle">L</text>
                
                <!-- RIGHT LABEL - LARGER Yellow square background -->
                <rect x="72" y="39" width="26" height="26" 
                      fill="#FFD700" 
                      stroke="#800000" 
                      stroke-width="2" 
                      rx="3"/>
                
                <!-- RIGHT LABEL - LARGER Bold R -->
                <text x="85" y="54" 
                      font-family="Arial, sans-serif" 
                      font-size="24" 
                      font-weight="900" 
                      fill="#0000FF" 
                      stroke="#FFFFFF" 
                      stroke-width="1"
                      paint-order="stroke"
                      text-anchor="middle"
                      dominant-baseline="middle">R</text>
            ` : '';
            
            token.innerHTML = `
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(${direction}deg); transition: transform 0.6s ease-out;">
                    <!-- Tail with wiggle animation -->
                    <g>
                        <path d="M 50 85 Q 45 92, 40 95 Q 35 98, 32 98" 
                              fill="none" stroke="#A0826D" stroke-width="3" 
                              stroke-linecap="round">
                            <animateTransform
                                attributeName="transform"
                                attributeType="XML"
                                type="rotate"
                                values="0 50 85; -8 50 85; 0 50 85; 8 50 85; 0 50 85"
                                keyTimes="0; 0.25; 0.5; 0.75; 1"
                                dur="1.2s"
                                repeatCount="indefinite"/>
                        </path>
                    </g>
                    
                    <!-- Body -->
                    <ellipse cx="50" cy="50" rx="22" ry="28" fill="#C0C0C0" 
                             stroke="#808080" stroke-width="1.5"/>
                    
                    <!-- Left Ear -->
                    <ellipse cx="35" cy="22" rx="12" ry="14" fill="#FFB6C1" 
                             stroke="#808080" stroke-width="1.5"/>
                    <ellipse cx="35" cy="22" rx="7" ry="9" fill="#FFC0CB"/>
                    
                    <!-- Right Ear -->
                    <ellipse cx="65" cy="22" rx="12" ry="14" fill="#FFB6C1" 
                             stroke="#808080" stroke-width="1.5"/>
                    <ellipse cx="65" cy="22" rx="7" ry="9" fill="#FFC0CB"/>
                    
                    <!-- Head -->
                    <ellipse cx="50" cy="30" rx="18" ry="20" fill="#C0C0C0" 
                             stroke="#808080" stroke-width="1.5"/>
                    
                    <!-- Snout -->
                    <ellipse cx="50" cy="20" rx="8" ry="6" fill="#B0B0B0"/>
                    
                    <!-- Nose -->
                    <circle cx="50" cy="18" r="2.5" fill="#FF69B4"/>
                    
                    <!-- Eyes -->
                    <circle cx="44" cy="28" r="2" fill="#000000"/>
                    <circle cx="56" cy="28" r="2" fill="#000000"/>
                    
                    <!-- Whiskers -->
                    <line x1="32" y1="25" x2="20" y2="23" stroke="#404040" stroke-width="1"/>
                    <line x1="32" y1="28" x2="20" y2="28" stroke="#404040" stroke-width="1"/>
                    <line x1="68" y1="25" x2="80" y2="23" stroke="#404040" stroke-width="1"/>
                    <line x1="68" y1="28" x2="80" y2="28" stroke="#404040" stroke-width="1"/>
                    
                    <!-- Small Green Cape (drawn last so it appears on top/back) with flowing animation -->
                    <path d="M 50 48 Q 38 51, 33 58 L 31 64 L 30 68 Q 29 70, 33 70 L 67 70 Q 71 70, 70 68 L 69 64 L 67 58 Q 62 51, 50 48 Z" 
                          fill="#006400" stroke="#004d00" stroke-width="1.5" opacity="0.9">
                        <animate attributeName="d" 
                            values="M 50 48 Q 38 51, 33 58 L 31 64 L 30 68 Q 29 70, 33 70 L 67 70 Q 71 70, 70 68 L 69 64 L 67 58 Q 62 51, 50 48 Z;
                                    M 50 48 Q 36 52, 32 59 L 30 65 L 29 69 Q 28 71, 32 71 L 68 71 Q 72 71, 71 69 L 70 65 L 68 59 Q 64 52, 50 48 Z;
                                    M 50 48 Q 40 50, 34 57 L 32 63 L 31 67 Q 30 69, 34 69 L 66 69 Q 70 69, 69 67 L 68 63 L 66 57 Q 60 50, 50 48 Z;
                                    M 50 48 Q 38 51, 33 58 L 31 64 L 30 68 Q 29 70, 33 70 L 67 70 Q 71 70, 70 68 L 69 64 L 67 58 Q 62 51, 50 48 Z" 
                            dur="2.5s" 
                            repeatCount="indefinite"/>
                    </path>
                    
                    <!-- Cape collar at back of head/neck with subtle movement -->
                    <ellipse cx="50" cy="49" rx="14" ry="3" fill="#228B22" stroke="#004d00" stroke-width="1">
                        <animate attributeName="ry" 
                            values="3;3.5;2.8;3" 
                            dur="2.5s" 
                            repeatCount="indefinite"/>
                    </ellipse>
                    
                    ${hintLabels}
                </svg>
            `;
            
            cell.appendChild(token);

            // Update position display
            if (translations[currentLanguage]) {
                const t = translations[currentLanguage];
                document.getElementById('position').textContent = 
                    `${t.row} ${tokenRow + 1}, ${t.col} ${tokenCol + 1}`;
            }
            
            // Check if mouse stepped on a trap (only if not skipped)
            if (!skipTrapCheck) {
                checkForTrap(false);
            }
        }

        // ===================================================================
        // SECTION 3: MOUSE MOVEMENT FUNCTIONS
        // ===================================================================
        // These functions handle all mouse movement and rotation
        // All movement functions reset the hint toggle automatically
        
        // Turn left (counter-clockwise) - Rotates mouse 90 degrees left
        // Resets hint mode and updates display with smooth rotation animation (0.6s)
        function turnLeft() {
            hintMode = false;                                      // Disable hint labels
            document.getElementById('hintToggle').checked = false; // Reset toggle switch visually
            direction = (direction - 90 + 360) % 360;             // Rotate 90Â° counter-clockwise
            updateToken();                                         // Refresh mouse display
        }

        // Turn right (clockwise) - Rotates mouse 90 degrees right
        // Resets hint mode and updates display with smooth rotation animation (0.6s)
        function turnRight() {
            hintMode = false;                                      // Disable hint labels
            document.getElementById('hintToggle').checked = false; // Reset toggle switch visually
            direction = (direction + 90) % 360;                   // Rotate 90Â° clockwise
            updateToken();                                         // Refresh mouse display
        }

        // Toggle hint mode - Shows/hides L/R directional labels on mouse
        // Activated by hint toggle switch above position label
        function toggleHint() {
            const hintToggle = document.getElementById('hintToggle');
            hintMode = hintToggle.checked;  // Set hint mode based on toggle state
            updateToken();                  // Refresh mouse display with/without labels
        }

        // Move forward in the direction the mouse is facing (1 cell)
        // Includes wall detection, cat danger zone checking, and trap collision
        // Parameters: skipTrapCheck - if true, delays trap checking until after animation
        function moveForward(skipTrapCheck = false) {
            hintMode = false;                                      // Disable hint labels on movement
            document.getElementById('hintToggle').checked = false; // Reset toggle switch visually
            
            let newRow = tokenRow;  // Calculate new position
            let newCol = tokenCol;
            let moveDir = null;     // Direction for animation

            // Determine new position based on current facing direction
            switch(direction) {
                case 0: // facing up
                    newRow = tokenRow - 1;
                    moveDir = 'up';
                    break;
                case 90: // facing right
                    newCol = tokenCol + 1;
                    moveDir = 'right';
                    break;
                case 180: // facing down
                    newRow = tokenRow + 1;
                    moveDir = 'down';
                    break;
                case 270: // facing left
                    newCol = tokenCol - 1;
                    moveDir = 'left';
                    break;
            }

            // Check boundaries before moving
            if (newRow >= 0 && newRow < gridHeight && newCol >= 0 && newCol < gridWidth) {
                // Check for wall at target position
                if (checkForWallAtPosition(newRow, newCol)) {
                    showWallError();
                    return false; // Movement blocked
                }
                
                // Check if moving into cat's danger zone
                if (isAdjacentToCat(newRow, newCol)) {
                    // Move to position first so cat catches mouse there
                    tokenRow = newRow;
                    tokenCol = newCol;
                    updateToken(true, moveDir); // Skip trap check, we're caught by cat
                    triggerCatAttack();
                    return false; // Caught by cat
                }
                
                tokenRow = newRow;
                tokenCol = newCol;
                updateToken(skipTrapCheck, moveDir);
                return true;
            }
            return false;
        }

        // Jump forward 2 cells in the direction the mouse is facing
        function jump(skipTrapCheck = false) {
            hintMode = false;
            document.getElementById('hintToggle').checked = false;
            
            let newRow = tokenRow;
            let newCol = tokenCol;
            let intermediateRow = tokenRow;
            let intermediateCol = tokenCol;
            let jumpDir = null;

            switch(direction) {
                case 0: // facing up
                    intermediateRow = tokenRow - 1;
                    newRow = tokenRow - 2;
                    jumpDir = 'up';
                    break;
                case 90: // facing right
                    intermediateCol = tokenCol + 1;
                    newCol = tokenCol + 2;
                    jumpDir = 'right';
                    break;
                case 180: // facing down
                    intermediateRow = tokenRow + 1;
                    newRow = tokenRow + 2;
                    jumpDir = 'down';
                    break;
                case 270: // facing left
                    intermediateCol = tokenCol - 1;
                    newCol = tokenCol - 2;
                    jumpDir = 'left';
                    break;
            }

            // Check boundaries before jumping
            if (newRow >= 0 && newRow < gridHeight && newCol >= 0 && newCol < gridWidth) {
                // Check for wall at intermediate position (can't jump over walls)
                if (checkForWallAtPosition(intermediateRow, intermediateCol)) {
                    showWallError();
                    return 'wall';
                }
                
                // Mouse CAN jump over traps, so no trap check at intermediate position
                
                // Check for wall at target position
                if (checkForWallAtPosition(newRow, newCol)) {
                    showWallError();
                    return 'wall';
                }
                
                // Check if jumping through or into cat's danger zone
                const jumpingThroughCat = isAdjacentToCat(intermediateRow, intermediateCol);
                const landingNearCat = isAdjacentToCat(newRow, newCol);
                
                if (jumpingThroughCat || landingNearCat) {
                    // Update position and trigger cat attack with jump animation
                    tokenRow = newRow;
                    tokenCol = newCol;
                    updateToken(true, 'jump-' + jumpDir); // Skip trap check, caught by cat
                    triggerCatAttack();
                    return 'cat'; // Caught by cat
                }
                
                // Update position with jump animation
                tokenRow = newRow;
                tokenCol = newCol;
                updateToken(skipTrapCheck, 'jump-' + jumpDir);
                return 'success';
            }
            return 'boundary'; // Out of bounds - silently skip
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    turnLeft();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    turnRight();
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    moveForward();
                    break;
                case ' ':
                case 'Spacebar':
                    e.preventDefault(); // Prevent page scrolling
                    jump();
                    break;
                case 'e':
                case 'E':
                    eatCheese();
                    break;
            }
        });

        async function executeCommands() {
            console.log('=== EXECUTE COMMANDS STARTED ===');
            console.log(`Total commands in list: ${commandList.length}`);
            console.log('Command list:', JSON.stringify(commandList));
            
            // In Level Book mode, reload entire level; in random mode, just reset position/cheese
            if (isLevelBookMode) {
                console.log('Level Book mode: reloading level with preserveCommands=true');
                // Reload entire level to restore all elements but KEEP commands
                loadLevelFromBook(currentLevelBookLevel, true); // true = preserveCommands
                // Small delay so user can see the reset
                await sleep(300);
            } else {
                console.log('Random mode: resetting position and cheese');
                // Reset to original starting position BEFORE executing commands
                tokenRow = initialRow;
                tokenCol = initialCol;
                direction = initialDirection;
                
                // Restore cheese to starting state and reset eaten cheese
                cheesePositions = JSON.parse(JSON.stringify(startingCheesePositions));
                eatenCheese = [];
                
                // Update display to show reset position
                updateCheeseDisplay();
                updateToken();
                
                // Small delay so user can see the reset
                await sleep(300);
            }
            
            console.log(`Starting position: (${tokenRow}, ${tokenCol}), direction: ${direction}Â°`);
            
            console.log(`Starting position: (${tokenRow}, ${tokenCol}), direction: ${direction}Â°`);
            
            for (let i = 0; i < commandList.length; i++) {
                const cmdObj = commandList[i];
                const cmd = cmdObj.cmd;
                const count = cmdObj.count;
                
                console.log(`\nExecuting command ${i+1}/${commandList.length}: "${cmd}" x${count}`);
                
                // Highlight current command (i+1 because START is at index 0)
                const items = document.querySelectorAll('.command-item');
                items.forEach(item => item.style.background = 'white');
                if (items[i + 1]) { // +1 to skip START
                    items[i + 1].style.background = '#ffffcc';
                }
                
                // Execute command 'count' times
                for (let repeat = 0; repeat < count; repeat++) {
                    console.log(`  Repeat ${repeat+1}/${count} of command "${cmd}"`);
                    
                    // Execute command
                    switch(cmd) {
                        case 'F': // Forward (English)
                        case 'V': // Vorentoe (Afrikaans)
                            console.log(`    Executing FORWARD from (${tokenRow}, ${tokenCol}) facing ${direction}Â°`);
                            const forwardSuccess = moveForward(true); // Skip trap check in updateToken
                            console.log(`    Forward result: ${forwardSuccess ? 'SUCCESS' : 'FAILED (hit wall)'}`);
                            // If hit a wall, stop execution
                            if (!forwardSuccess) {
                                await sleep(2500);
                                const items = document.querySelectorAll('.command-item');
                                items.forEach(item => item.style.background = 'white');
                                console.log('=== EXECUTION STOPPED: Hit wall ===');
                                attemptAgain();
                                return;
                            }
                            console.log(`    New position: (${tokenRow}, ${tokenCol})`);
                            // Check for trap after moving
                            if (checkForTrap(true)) {
                                await sleep(2500);
                                const items = document.querySelectorAll('.command-item');
                                items.forEach(item => item.style.background = 'white');
                                console.log('=== EXECUTION STOPPED: Hit trap ===');
                                attemptAgain();
                                return;
                            }
                            break;
                        case 'J': // Jump (English)
                        case 'S': // Spring (Afrikaans)
                            console.log(`    Executing JUMP from (${tokenRow}, ${tokenCol}) facing ${direction}Â°`);
                            const jumpResult = jump(true); // Skip trap check in updateToken
                            console.log(`    Jump result: ${jumpResult}`);
                            
                            if (jumpResult === 'wall') {
                                // Hit a wall - stop execution
                                await sleep(2500);
                                const items = document.querySelectorAll('.command-item');
                                items.forEach(item => item.style.background = 'white');
                                console.log('=== EXECUTION STOPPED: Jump hit wall ===');
                                attemptAgain();
                                return;
                            } else if (jumpResult === 'cat') {
                                // Caught by cat - stop execution
                                await sleep(2500);
                                const items = document.querySelectorAll('.command-item');
                                items.forEach(item => item.style.background = 'white');
                                console.log('=== EXECUTION STOPPED: Caught by cat ===');
                                return;
                            } else if (jumpResult === 'boundary') {
                                // Out of bounds - skip this jump silently, continue execution
                                console.log('    Jump out of bounds - skipping');
                                break;
                            }
                            // jumpResult === 'success'
                            console.log(`    New position: (${tokenRow}, ${tokenCol})`);
                            await sleep(800); // Wait for jump animation
                            // Check for trap after jumping
                            if (checkForTrap(true)) {
                                await sleep(2500);
                                const items = document.querySelectorAll('.command-item');
                                items.forEach(item => item.style.background = 'white');
                                console.log('=== EXECUTION STOPPED: Jumped onto trap ===');
                                attemptAgain();
                                return;
                            }
                            break;
                        case 'R':
                            console.log(`    Executing TURN RIGHT from ${direction}Â°`);
                            turnRight();
                            console.log(`    New direction: ${direction}Â°`);
                            break;
                        case 'L':
                            console.log(`    Executing TURN LEFT from ${direction}Â°`);
                            turnLeft();
                            console.log(`    New direction: ${direction}Â°`);
                            break;
                        case 'E':
                            console.log(`    Executing EAT at (${tokenRow}, ${tokenCol})`);
                            eatCheese();
                            console.log(`    Cheese remaining: ${cheesePositions.length}`);
                            await sleep(600); // Wait for message
                            
                            // Check if all cheese collected
                            if (cheesePositions.length === 0) {
                                await sleep(400);
                                const t = translations[currentLanguage];
                                
                                // Handle Level Book mode progression
                                if (isLevelBookMode) {
                                    if (currentLevelBookLevel < 15) {
                                        // More levels to go - advance to next level
                                        showMessage(t.wellDone, 2500, true);
                                        await sleep(2500);
                                        
                                        // Advance to next level
                                        currentLevelBookLevel++;
                                        clearCommands();
                                        loadLevelFromBook(currentLevelBookLevel);
                                        
                                        // Show level transition message
                                        await sleep(500);
                                        const levelMsg = currentLanguage === 'en' 
                                            ? `ðŸŽ¯ Level ${currentLevelBookLevel} of 15`
                                            : `ðŸŽ¯ Vlak ${currentLevelBookLevel} van 15`;
                                        showMessage(levelMsg, 2000);
                                    } else {
                                        // All levels complete!
                                        const completeMsg = currentLanguage === 'en'
                                            ? 'ðŸ† AMAZING! ðŸ†\nAll 15 levels completed!\n\nðŸŽ‰ YOU ARE A CODING MASTER! ðŸŽ‰'
                                            : 'ðŸ† WONDERLIK! ðŸ†\nAl 15 vlakke voltooi!\n\nðŸŽ‰ JY IS \'N KODEERMEESTER! ðŸŽ‰';
                                        showMessage(completeMsg, 4000, true);
                                        await sleep(4000);
                                        
                                        // Reset to level 1 for replay
                                        currentLevelBookLevel = 1;
                                        clearCommands();
                                        loadLevelFromBook(currentLevelBookLevel);
                                    }
                                } else {
                                    // Random mode - original behavior
                                    showMessage(t.wellDone, 2500, true);
                                    await sleep(2500);
                                    clearCommands();
                                    placeRandomCheese();
                                }
                                
                                // Stop execution after celebration
                                const items = document.querySelectorAll('.command-item');
                                items.forEach(item => item.style.background = 'white');
                                return;
                            }
                            break;
                        default:
                            console.error(`    UNRECOGNIZED COMMAND: "${cmd}"`);
                            console.error(`    This command is not recognized by the execution system!`);
                            break;
                }
                
                // Wait before next repetition (shorter delay within repeats)
                if (repeat < count - 1) {
                    await sleep(cmd === 'J' || cmd === 'S' ? 400 : 600);
                }
            }
                
                // Wait before next command (longer delay between commands)
                await sleep(cmd === 'J' || cmd === 'S' ? 400 : 600);
            }
            
            // Remove highlight after execution
            const items = document.querySelectorAll('.command-item');
            items.forEach(item => item.style.background = 'white');
            
            console.log('=== EXECUTION COMPLETED SUCCESSFULLY ===');
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ===================================================================
        // DEVELOPER CHEAT - LEVEL SKIP
        // ===================================================================
        // Double-click the level indicator bar to skip to any level
        
        function levelSkipCheat() {
            if (!isLevelBookMode) return;
            const input = prompt(`ðŸ”§ Dev Cheat: Jump to level (1-15):\nCurrent level: ${currentLevelBookLevel}`);
            if (input === null) return; // Cancelled
            const targetLevel = parseInt(input);
            if (isNaN(targetLevel) || targetLevel < 1 || targetLevel > 15) {
                alert('Invalid level! Enter a number between 1 and 15.');
                return;
            }
            currentLevelBookLevel = targetLevel;
            clearCommands();
            loadLevelFromBook(currentLevelBookLevel);
            showMessage(`ðŸ”§ Skipped to Level ${currentLevelBookLevel}`, 1500);
        }

        // ===================================================================
        // GRID SCREENSHOT FUNCTIONALITY
        // ===================================================================
        // Right-click on grid to save as PNG image for paper-based exercises.
        // Draws the grid manually onto a Canvas - no html2canvas needed.
        // Both the mouse and cat use their actual SVG artwork.
        
        // Cat SVG markup (static snapshot - no animations)
        const CAT_SVG_MARKUP = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 260 240" width="100" height="100">
            <path d="M205 145 q45 10 25 45 q-5 18 -30 10" fill="none" stroke="#d97a1f" stroke-width="14" stroke-linecap="round"/>
            <ellipse cx="135" cy="155" rx="75" ry="40" fill="#f39c3d"/>
            <path d="M90 145 q20 -15 40 0" stroke="#ffd24d" stroke-width="7" fill="none"/>
            <path d="M105 165 q20 -15 40 0" stroke="#ffd24d" stroke-width="7" fill="none"/>
            <path d="M120 185 q20 -15 40 0" stroke="#ffd24d" stroke-width="7" fill="none"/>
            <circle cx="120" cy="90" r="45" fill="#f6b15a"/>
            <path d="M80 55 L60 25 L95 40 Z" fill="#f6b15a"/>
            <path d="M78 52 L70 35 L92 42 Z" fill="#f9c99a"/>
            <path d="M160 55 L180 25 L145 40 Z" fill="#f6b15a"/>
            <path d="M162 52 L170 35 L148 42 Z" fill="#f9c99a"/>
            <ellipse cx="105" cy="88" rx="13" ry="18" fill="#fff"/>
            <ellipse cx="135" cy="88" rx="13" ry="18" fill="#fff"/>
            <ellipse cx="105" cy="92" rx="7" ry="11" fill="#3a7f5c"/>
            <ellipse cx="135" cy="92" rx="7" ry="11" fill="#3a7f5c"/>
            <ellipse cx="105" cy="95" rx="3" ry="8" fill="#000"/>
            <ellipse cx="135" cy="95" rx="3" ry="8" fill="#000"/>
            <circle cx="102" cy="84" r="3" fill="#fff"/>
            <circle cx="132" cy="84" r="3" fill="#fff"/>
            <path d="M88 70 q16 -12 32 -4" stroke="#7a1e2c" stroke-width="3" fill="none"/>
            <path d="M122 66 q20 -2 34 10" stroke="#7a1e2c" stroke-width="3" fill="none"/>
            <polygon points="120,98 114,105 126,105" fill="#e56"/>
            <path d="M106 116 q10 6 20 -2 q6 -2 10 -6" stroke="#222" stroke-width="3" fill="none"/>
            <path d="M78 92 l-28 -6" stroke="#333" stroke-width="2"/>
            <path d="M76 102 l-30 0" stroke="#333" stroke-width="2"/>
            <path d="M78 112 l-28 6" stroke="#333" stroke-width="2"/>
            <path d="M162 92 l28 -6" stroke="#333" stroke-width="2"/>
            <path d="M164 102 l30 0" stroke="#333" stroke-width="2"/>
            <path d="M162 112 l28 6" stroke="#333" stroke-width="2"/>
            <ellipse cx="175" cy="182" rx="14" ry="9" fill="#c97a2a"/>
            <ellipse cx="195" cy="180" rx="13" ry="8" fill="#c97a2a"/>
            <path d="M170 188 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M176 188 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M182 188 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M190 186 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M196 186 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M202 186 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <ellipse cx="95" cy="185" rx="15" ry="10" fill="#f5c285"/>
            <ellipse cx="115" cy="187" rx="14" ry="9" fill="#f5c285"/>
            <path d="M88 192 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M95 193 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M102 192 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M108 194 l-2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M115 195 l0 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
            <path d="M122 194 l2 4" stroke="#444" stroke-width="2.5" stroke-linecap="round"/>
        </svg>`;

        function saveGridAsImage() {
            // Generate filename
            const now = new Date();
            const datetime = now.toISOString()
                .replace(/[-:]/g, '_')
                .replace(/T/, '_')
                .split('.')[0];
            const gridSize = isLevelBookMode
                ? `5x5_LevelBook_Lvl${currentLevelBookLevel}`
                : `${gridWidth}x${gridHeight}`;
            const filename = `Manie_${gridSize}_${datetime}.png`;

            // Canvas dimensions
            const CELL  = 80;   // pixels per cell in output image
            const GAP   = 2;    // gap between cells
            const TOTAL_W = gridWidth  * CELL + (gridWidth  + 1) * GAP;
            const TOTAL_H = gridHeight * CELL + (gridHeight + 1) * GAP;

            const canvas = document.createElement('canvas');
            canvas.width  = TOTAL_W;
            canvas.height = TOTAL_H;
            const ctx = canvas.getContext('2d');

            // Helper: get pixel origin of a cell
            function cellX(col) { return GAP + col * (CELL + GAP); }
            function cellY(row) { return GAP + row * (CELL + GAP); }

            // â”€â”€ 1. Background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ctx.fillStyle = '#b0b0b0';
            ctx.fillRect(0, 0, TOTAL_W, TOTAL_H);

            // â”€â”€ 2. Draw all cells â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            for (let r = 0; r < gridHeight; r++) {
                for (let c = 0; c < gridWidth; c++) {
                    ctx.fillStyle = '#f0f0f0';
                    ctx.strokeStyle = '#cccccc';
                    ctx.lineWidth = 1;
                    ctx.fillRect(cellX(c), cellY(r), CELL, CELL);
                    ctx.strokeRect(cellX(c), cellY(r), CELL, CELL);
                }
            }

            // â”€â”€ 3. Emoji helper (walls, traps, cheese) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const EMOJI_SIZE = Math.floor(CELL * 0.72);
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';

            function drawEmoji(emoji, row, col) {
                ctx.font = `${EMOJI_SIZE}px serif`;
                ctx.fillText(emoji,
                    cellX(col) + CELL / 2,
                    cellY(row) + CELL / 2 + 2);
            }

            wallPositions.forEach(p  => drawEmoji('ðŸ§±', p.row, p.col));
            trapPositions.forEach(p  => drawEmoji('ðŸª¤', p.row, p.col));
            cheesePositions.forEach(p => drawEmoji('ðŸ§€', p.row, p.col));

            // â”€â”€ 4. Helper: load SVG string as Image then draw on canvas â”€â”€
            function drawSvgOnCanvas(svgMarkup, row, col, size, callback) {
                const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgMarkup);
                const img = new Image();
                img.onload = function() {
                    const cx = cellX(col) + CELL / 2;
                    const cy = cellY(row) + CELL / 2;
                    ctx.drawImage(img, cx - size / 2, cy - size / 2, size, size);
                    callback();
                };
                img.onerror = function() {
                    // Fallback to emoji if SVG fails
                    drawEmoji(row === tokenRow && col === tokenCol ? 'ðŸ­' : 'ðŸ±', row, col);
                    callback();
                };
                img.src = dataUrl;
            }

            // â”€â”€ 5. Draw cats then mouse (sequential async chain) â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const catSize = CELL * 0.88;

            function drawCatsSequentially(index, afterAll) {
                if (index >= catPositions.length) {
                    afterAll();
                    return;
                }
                const pos = catPositions[index];
                drawSvgOnCanvas(CAT_SVG_MARKUP, pos.row, pos.col, catSize, function() {
                    drawCatsSequentially(index + 1, afterAll);
                });
            }

            function drawMouse(afterDone) {
                const tokenDiv = document.querySelector('.token');
                const tokenSvg = tokenDiv ? tokenDiv.querySelector('svg') : null;

                if (!tokenSvg) { afterDone(); return; }

                // Clone SVG, strip animations for clean static snapshot
                const svgClone = tokenSvg.cloneNode(true);
                svgClone.querySelectorAll('animate, animateTransform').forEach(a => a.remove());
                svgClone.setAttribute('width',  '100');
                svgClone.setAttribute('height', '100');

                const svgStr = new XMLSerializer().serializeToString(svgClone);
                const mouseSize = CELL * 0.85;
                drawSvgOnCanvas(svgStr, tokenRow, tokenCol, mouseSize, afterDone);
            }

            function finishAndDownload() {
                canvas.toBlob(blob => {
                    const url  = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href     = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    console.log(`Grid saved as: ${filename}`);
                }, 'image/png');
            }

            // Draw cats first, then mouse, then download
            drawCatsSequentially(0, function() {
                drawMouse(finishAndDownload);
            });
        }
        
        // Add right-click event listener to grid
        window.addEventListener('DOMContentLoaded', function() {
            const grid = document.getElementById('grid');
            
            if (grid) {
                grid.addEventListener('contextmenu', function(e) {
                    e.preventDefault(); // Prevent default context menu
                    
                    // Simple confirm dialog
                    const userConfirmed = confirm('Save grid as image for paper-based exercises?');
                    
                    if (userConfirmed) {
                        saveGridAsImage();
                    }
                });
            }
        });

        // Game will initialize after language selection
        
        // Initialize splash screen with English text on page load
        window.addEventListener('DOMContentLoaded', function() {
            currentLanguage = 'en';
            updateSplashText();
        });
    </script>
</body>
</html>

<!--
<!--
================================================================================
COMPREHENSIVE GAME DOCUMENTATION
================================================================================
The following documentation provides complete technical details about the game
structure, mechanics, and implementation. This serves as both developer
reference and maintenance guide.
================================================================================
-->

<!--
================================================================================
THE LOGICAL ADVENTURES OF CLEVER MANIE MALAN THE CODING MOUSE
DEVELOPER DOCUMENTATION
================================================================================

Version: 2.0
Last Updated: February 2026
File: ManieMalan_PWA_V2.html (Single-file HTML/CSS/JavaScript)

================================================================================
TABLE OF CONTENTS
================================================================================

1.  OVERVIEW
2.  FILE STRUCTURE
3.  GAME CONFIGURATION & STATE
4.  CSS STYLING ARCHITECTURE
5.  JAVASCRIPT MODULES
6.  TRANSLATIONS SYSTEM
7.  GAME MECHANICS
8.  LEVEL BOOK SYSTEM
9.  ANIMATION SYSTEM
10. PATHFINDING ALGORITHM
11. DEVELOPER CHEAT - LEVEL SKIP
12. GRID SCREENSHOT FEATURE
13. EXTENDING THE GAME
14. TROUBLESHOOTING

================================================================================
1. OVERVIEW
================================================================================

"The Logical Adventures of Clever Manie Malan the Coding Mouse" is an
educational block-based programming game designed for Grade 4-5 learners.
Players build a sequential command list to guide Manie the mouse to collect
all cheese while avoiding obstacles. The program only runs when the player
clicks Execute - mirroring the write-then-run model of real programming.

TARGET AUDIENCE:
- Primary school students (ages 9-12)
- Bilingual: English and Afrikaans

EDUCATIONAL OBJECTIVES:
- Sequential programming concepts
- Logical thinking and problem-solving
- Understanding of loops and repetition
- Spatial reasoning and grid navigation
- Strategic thinking (jump can bypass traps)

GAME MODES:
- Random Mode:     5 difficulty levels, randomly generated grids each time
- Level Book Mode: 15 handcrafted levels on a fixed 5x5 grid, played in order

================================================================================
2. FILE STRUCTURE
================================================================================

Single HTML file with embedded CSS and JavaScript for easy distribution.

STRUCTURE:
  ManieMalan_PWA_V2.html
  |-- Header comment (version, features, developer info)
  |-- <style> (all CSS)
  |   |-- Splash screen styles
  |   |-- Game container and layout
  |   |-- Grid and cell styles
  |   |-- Token (mouse) styles and animations
  |   |-- Control button styles
  |   |-- Command list styles
  |   |-- Message overlay styles
  |   +-- Animation @keyframes
  |-- <body>
  |   |-- #splashScreen       (language/mode selection)
  |   |-- #instructionsPage   (how to play, both languages)
  |   +-- #gameContainer      (main game interface)
  |       |-- .game-area      (grid, controls, hint toggle, level indicator)
  |       +-- .command-area   (command list, action buttons)
  |-- <script>
  |   |-- Translation system (translations object)
  |   |-- Splash screen logic
  |   |-- Game state variables
  |   |-- Level Book data (15 levels)
  |   |-- Grid management functions
  |   |-- Token (mouse) movement functions
  |   |-- Obstacle checking functions
  |   |-- Command system (add, remove, execute)
  |   |-- Game flow functions
  |   |-- Developer cheat (levelSkipCheat)
  |   |-- Grid screenshot (saveGridAsImage)
  |   +-- Initialization (DOMContentLoaded)
  +-- End-of-file documentation (this section)

================================================================================
3. GAME CONFIGURATION & STATE
================================================================================

RANDOM MODE GRID CONFIGURATIONS (gridConfigs object):
------------------------------------------------------
  1: { width:4, height:3, cheese:1, traps:0, walls:0, cats:0 }  Tutorial
  2: { width:4, height:4, cheese:1, traps:0, walls:1, cats:0 }  Easy
  3: { width:5, height:5, cheese:1, traps:1, walls:3, cats:1 }  Medium
  4: { width:7, height:5, cheese:2, traps:3, walls:5, cats:1 }  Hard
  5: { width:9, height:6, cheese:3, traps:5, walls:5, cats:2 }  Expert

LEVEL BOOK: Fixed 5x5 grid, 15 handcrafted levels (see Section 8)

KEY STATE VARIABLES:
  currentGridConfig       - Selected random difficulty (1-5)
  isLevelBookMode         - true when Level Book mode active
  currentLevelBookLevel   - Active Level Book level (1-15)
  gridWidth / gridHeight  - Active grid dimensions
  tokenRow / tokenCol     - Mouse position (0-indexed)
  direction               - Facing: 0=up, 90=right, 180=down, 270=left
  initialRow/Col/Direction - Saved start state for reset
  cheesePositions[]       - [{row,col}] active cheese remaining
  startingCheesePositions[] - Snapshot at level start (for reset)
  eatenCheese[]           - Collected cheese this run
  trapPositions[]         - [{row,col}]
  wallPositions[]         - [{row,col}]
  catPositions[]          - [{row,col}]
  hintMode                - true when L/R labels shown on mouse
  currentLanguage         - 'en' or 'af'

================================================================================
4. CSS STYLING ARCHITECTURE
================================================================================

COLOR SCHEME:
  Primary Green:   #006400  (borders, headers)
  Secondary Green: #228B22  (backgrounds)
  Gold/Yellow:     #FFD700  (title, level indicator)
  Purple:          #9c27b0 to #7b1fa2  (Return to Menu button)
  Danger Red:      #e53935, #dc143c   (errors, cat attacks)
  Success Green:   #43a047
  Neutral Gray:    #f0f0f0  (cell backgrounds)

KEY CSS CLASSES:

  Splash screen:
    #splashScreen              Full-screen overlay
    .splash-container          Centered white card
    .splash-character-container Animated mouse SVG (with flowing cape)
    .splash-cat-left/right     Bouncing cats beside title
    .splash-cheese-float       Floating cheese pieces
    .splash-sparkle            Sparkle particle effects
    .splash-grid-column        Left/right columns for mode selection

  Grid and cells:
    .grid                      CSS Grid container (dynamic columns x rows)
    .cell                      Individual 60x60px grid cell
    .cheese                    Cheese emoji overlay on cell
    .trap                      Trap emoji overlay on cell
    .wall                      Wall emoji overlay on cell
    .cat                       Animated cat SVG container on cell

  Mouse token:
    .token                     Mouse character (absolutely positioned)
    .move-up/down/left/right   Slide movement animations (0.35s)
    .jump-up/down/left/right   Arc jump animations (0.75s)

  Controls:
    .controls                  Row of movement buttons
    .control-with-repeat       Single button + its repeat counter
    .repeat-control            The +/- buttons and count display
    .action-buttons            Execute/AttemptAgain/Clear/NewGame/Menu

  Messages:
    .message-overlay           Centered popup for all game messages
    .message-overlay.cat-caught Red background for cat attack
    .celebration-container     Floating emoji rain for win

  Level indicator:
    #levelIndicator            Yellow bar "Level X of 15"
    (double-click activates developer level-skip cheat)

ANIMATION @KEYFRAMES:
  float              Cheese bobbing on splash screen
  sparkle            Sparkle particles fade in/out
  catProwl           Cat prowling on splash screen
  slideFromBelow/Above/Left/Right  Mouse movement slide-in (4 directions)
  jumpSlideUp/Down/Left/Right      Mouse jump arc (4 directions)
  catAttack          Cat pounce using CSS custom properties
  pulse              General pulsing glow effect
  capeBillow         Mouse cape flowing (2.5s, 4-keyframe path morph)

================================================================================
5. JAVASCRIPT MODULES
================================================================================

A. TRANSLATION SYSTEM
  translations = { en:{...}, af:{...} }
  updateSplashText()   - Rebuilds all splash screen text
  toggleLanguage(lang) - Switches language, updates all UI text
  updateGameText()     - Updates in-game labels and indicators

B. GRID MANAGEMENT
  createGrid()
    Creates gridWidth x gridHeight cell divs in #grid element.
    After 100ms stores pixel dimensions in window.gridScreenshotBounds
    for the screenshot feature.

  placeRandomCheese()
    Randomly places all elements for Random Mode.
    Order: cats > mouse relocation > cheese > traps > walls
    Validates with hasValidPathToCheese(), retries up to 30 times.
    Sets initialRow/Col/Direction on success.

  updateCheeseDisplay()  Rebuilds cheese DOM from cheesePositions[]
  updateTrapDisplay()    Rebuilds trap DOM from trapPositions[]
  updateWallDisplay()    Rebuilds wall DOM from wallPositions[]
  updateCatDisplay()     Rebuilds animated cat SVGs from catPositions[]

C. TOKEN (MOUSE) MANAGEMENT
  updateToken(skipTrapCheck, moveDirection)
    Removes old token, creates new SVG at (tokenRow, tokenCol).
    Applies CSS rotation for direction (0/90/180/270 degrees).
    Applies move/jump animation class based on moveDirection.
    If hintMode=true: renders mouse with large L/R labels.
    If skipTrapCheck=false: immediately checks for trap at new position.

  turnLeft() / turnRight()
    Adjusts direction by +/-90 degrees, resets hintMode.

  moveForward(skipTrapCheck)
    Calculates new position. Checks boundary, wall, cat danger zone.
    Returns true (success) or false (blocked).

  jump(skipTrapCheck)
    Calculates intermediate cell and landing cell (2 steps ahead).
    Returns one of four string values:
      'success'  - jumped successfully, continue execution
      'wall'     - wall blocked jump, stop execution + attemptAgain
      'cat'      - landed in cat zone, trigger attack, stop execution
      'boundary' - out of grid bounds, SILENTLY SKIP, continue execution
    CAN jump over traps (no trap check at intermediate cell).
    CANNOT jump over walls (checked at both intermediate and landing).

  toggleHint()
    Toggles hintMode, re-renders mouse with/without L/R labels.

D. OBSTACLE CHECKING
  checkForTrap(duringExecution)
    Checks if mouse is on a trap. If yes: game over message + attemptAgain.

  checkForWallAtPosition(row, col)
    Returns true if position is in wallPositions[].

  isAdjacentToCat(row, col)
    Returns true if position is within 1 cell (incl. diagonal) of any cat.
    Formula: abs(cat.row - row) <= 1 AND abs(cat.col - col) <= 1

  triggerCatAttack()
    Finds nearest cat by Euclidean distance.
    Only that cat's DOM element gets .attacking CSS class.
    Sets CSS custom properties for attack direction/position.

  hasValidPathToCheese()
    BFS from mouse position. Blocked by: walls, traps, cat zones, OOB.
    Returns true only if ALL cheesePositions are reachable.
    Used for random level validation only (not Level Book levels).

E. COMMAND SYSTEM
  commandList = [{cmd:'START'}, {cmd:'F', count:1}, ..., {cmd:'STOP'}]

  addCommand(type)    Appends {cmd:type, count:1}, re-renders list
  removeCommand(idx)  Removes command at index (not START/STOP)
  clearCommands()     Resets list to [START, STOP]

  executeCommands() [async]
    Level Book: calls loadLevelFromBook(level, preserveCommands=true)
    Random: resets position/cheese to initial state
    Iterates commandList, executes each command count times.
    Highlights active command in yellow.
    Jump 'boundary' result: break inner loop, continue outer (silent skip)
    Jump 'wall'/'cat' result: stop execution, show message, attemptAgain
    After all cheese eaten: advance level or show completion/new game.

F. GAME FLOW
  showGame()         Hides splash, shows game. Always fully reinitializes.
  returnToMenu()     Hides game, shows splash. Resets mode and level.
  newGame()          Random: new random layout. Level Book: reload current level.
  attemptAgain()     Restore to initial state, keep commands.
  showMessage(text, duration, isCelebration, isCatCaught)

================================================================================
6. TRANSLATIONS SYSTEM
================================================================================

STRUCTURE:
  translations.en and translations.af both contain:
    - UI labels (buttons, indicators, titles)
    - Game messages (njomNjom, wellDone, gameOver, wallHit, catCaught)
    - Instructions HTML (instructionsContent - full HTML string)
    - Command display names (commands: {F:'Forward', J:'Jump', ...})

COMMAND CODES:
  English:   F=Forward, J=Jump, R=Turn Right, L=Turn Left, E=Eat
  Afrikaans: V=Vorentoe, S=Spring, R=Regs, L=Links, E=Eet
  Note: R and L codes are same in both languages.
  Execute loop handles both V/F for Forward and S/J for Jump.

TO ADD A NEW LANGUAGE:
  1. Add key to translations object with all required strings
  2. Add language button to splash screen HTML
  3. Update toggleLanguage() and updateGameText()
  4. Ensure command codes don't conflict with F,J,R,L,E,V,S

================================================================================
7. GAME MECHANICS
================================================================================

MOVEMENT:
  Directions: 0=up, 90=right, 180=down, 270=left
  Forward: 1 cell in facing direction
  Jump:    2 cells in facing direction (skips intermediate cell)
  Turn:    90 degree rotation, no movement

OBSTACLE INTERACTIONS:

  CHEESE (cheese emoji):
    Does NOT auto-collect on landing.
    Must use Eat command while standing on cheese cell.
    Win = cheesePositions.length === 0 after an Eat command.

  TRAPS (trap emoji):
    Step on trap = immediate game over + auto-reset.
    Jump OVER trap (intermediate) = safe.
    Land ON trap after jump = game over.
    BFS treats traps as impassable (conservative validation).

  WALLS (brick emoji):
    Block Forward movement entirely.
    Block Jump at both intermediate AND landing cell.
    Cannot navigate through or over walls by any means.

  CATS (cat emoji):
    9-cell danger zone (cat + 8 surrounding cells).
    Entering any danger zone cell = cat attack + game over.
    Only the geometrically nearest cat attacks.
    Cat positions are fixed for the entire game/level.

COMMAND EXECUTION MODEL:
  1. Player builds command list
  2. Player clicks Execute
  3. Level state resets to start (position + cheese)
  4. Commands execute sequentially with animation delays
  5. Failure: stop, show message, auto-reset position
  6. Success: celebration, advance level or new game

================================================================================
8. LEVEL BOOK SYSTEM
================================================================================

15 handcrafted levels on a fixed 5x5 grid. All verified solvable manually.

LEVEL DATA FORMAT:
  Standard: plain 2D array
    1: [ ['','W','','',''], ['M','','','<',''], ... ]

  With direction override: object format
    7: { grid: [ [...], ... ], initialDirection: 0 }
    (0=up, 90=right, 180=down, 270=left)

CELL VALUES:  M=Mouse  <=Cheese  T=Trap  W=Wall  C=Cat  ''=Empty

DIRECTION OVERRIDE (Level 7):
  Without override, auto-direction would face mouse toward nearest cheese
  (bottom-right), making the solution impossible. Forcing UP enables:
  Forward > Forward > Turn Right > Jump (over row-0 trap) > reach right column.

LEVEL OVERVIEW:
  1-5:   Original challenges (walking + basic jumps)
  6-10:  Intermediate (multiple cats, traps, confined paths)
  11-15: Expert (perimeter mazes, pure wall maze, complex layouts)

  Notable levels:
  Level  7: Mouse walled in center - must go up and jump over top-row trap
  Level  9: Jump over wall at (0,3) to reach cheese at (0,4)
  Level 10: Jump over both traps in row 2; boundary jump silently skips
  Level 11: Perimeter path around central cat; 7 cheese pieces
  Level 12: Pure wall maze, no cats or traps
  Level 13: Two jumps needed to cross wall rows
  Level 15: All walls + cat in center; elegant perimeter design

loadLevelFromBook(levelNum, preserveCommands=false):
  Sets grid to 5x5.
  Parses level (handles array and object formats).
  Populates all position arrays and saves initial state.
  Sets direction from override OR auto-toward-closest-cheese.
  If preserveCommands=true: keeps command list (used by executeCommands).

LEVEL COMPLETE FLOW:
  Last cheese eaten
    > "Well Done" message (2.5s)
    > currentLevelBookLevel++
    > loadLevelFromBook(new level)
    > "Level X of 15" message (2s)
  After level 15:
    > "All 15 levels completed!" (4s)
    > Reset to level 1

================================================================================
9. ANIMATION SYSTEM
================================================================================

SVG CHARACTER ANIMATIONS (SMIL):
  Mouse (splash + in-game):
    Tail wiggle: animateTransform rotate on tail path
    Cape billow: animate attributeName="d", 4-keyframe path morph, 2.5s cycle
    Cape collar: synchronized ry animation (8>9>7.5>8)

  Cats (all instances):
    Tail sway, whisker movement, ear flick: animateTransform rotate

CSS MOVEMENT ANIMATIONS:
  Mouse slides (0.35s ease-out):
    .token.move-up    > slideFromBelow
    .token.move-down  > slideFromAbove
    .token.move-left  > slideFromRight
    .token.move-right > slideFromLeft

  Mouse jumps (0.75s ease-out):
    .token.jump-up/down/left/right > jumpSlideUp/Down/Left/Right
    Keyframes: 0% start > 15% anticipation crouch > 40% peak stretch > 100% land

  Mouse rotation: CSS transform rotate(), transition 0.6s ease-out

  Cat attack (1.6s, nearest cat only):
    CSS custom properties set per attack:
      --attack-x, --attack-y       pixel offset to mouse
      --attack-rotation            angle cat faces toward mouse
      --attack-flip                mirror if attacking left
      --original-rotation/flip     return values after attack

TIMING REFERENCE:
  Mouse movement animation:   350ms
  Mouse turn rotation:        600ms
  Jump animation:             750ms  (800ms await in execute loop)
  Execute delay between cmds: 600ms  (400ms for jumps)
  Cat attack animation:       1600ms
  Well done message:          2500ms
  Level transition delay:      500ms
  Level transition message:   2000ms

================================================================================
10. PATHFINDING ALGORITHM (RANDOM MODE ONLY)
================================================================================

BFS validates that randomly generated levels are solvable by walking.
Level Book levels skip BFS - they are pre-validated manually.

ALGORITHM SUMMARY:
  Start from (tokenRow, tokenCol).
  Expand in 4 directions (up/down/left/right).
  Block: out-of-bounds, walls, traps, cat danger zones.
  Return true if ALL cheesePositions are in reachable set.

NOTE ON JUMPING AND BFS:
  BFS models walking only. Cheese reachable ONLY by jumping will cause
  BFS to return false and trigger a retry. Random levels are always
  walkable. Only Level Book levels (pre-validated) may require jumps.

PLACEMENT ORDER (placeRandomCheese):
  1. Place cats
  2. Relocate mouse if inside cat danger zone
  3. Mark cat danger zones + mouse position as blocked
  4. Place cheese (avoid blocked cells)
  5. Place traps (avoid blocked + cheese)
  6. Place walls (avoid all occupied)
  7. Run BFS validation > retry up to 30 times if invalid

================================================================================
11. DEVELOPER CHEAT - LEVEL SKIP
================================================================================

PURPOSE: Jump to any Level Book level for testing without playing through.

ACTIVATION:
  Double-click the yellow "Level X of 15" indicator bar.
  Only works in Level Book mode (ignored in Random mode).

BEHAVIOUR:
  Prompts for target level (1-15).
  Validates input. Loads level. Shows "Skipped to Level X" message.
  Clears command list. Invalid input shows alert. Cancel does nothing.

IMPLEMENTATION:
  function levelSkipCheat() attached via ondblclick on #levelIndicator div.

================================================================================
12. GRID SCREENSHOT FEATURE
================================================================================

PURPOSE: Save the current grid as a PNG for paper-based exercise worksheets.

ACTIVATION: Right-click anywhere on the grid. Confirm in dialog.

FILENAME FORMAT:
  Random:     Manie_6x9_2026_02_16_14_30_25.png
  Level Book: Manie_5x5_LevelBook_Lvl3_2026_02_16_14_30_25.png

IMPLEMENTATION:
  Uses html2canvas (cdnjs CDN). Grid pixel dimensions stored in
  window.gridScreenshotBounds 100ms after createGrid() runs.
  Captures at 2x scale for higher output quality.

NOTE: Manual crop may be needed. If CDN unavailable, feature fails
  with an alert. All other game features work fully offline.

================================================================================
13. EXTENDING THE GAME
================================================================================

ADDING A NEW OBSTACLE:
  1. Add count to gridConfigs entries
  2. Declare positions array
  3. Add placement in placeRandomCheese()
  4. Create updateXxxDisplay() function
  5. Add collision detection in moveForward() and jump()
  6. Add to BFS exclusions if it blocks movement
  7. Create CSS class and visual representation
  8. Update instructions in both language objects

ADDING A NEW COMMAND:
  1. Add button HTML in .controls div
  2. Add to translations.commands for both languages
  3. Add case in executeCommands() switch statement
  4. Implement command function
  5. Add keyboard shortcut in keydown handler
  6. Update instructions in both language objects

ADDING MORE LEVEL BOOK LEVELS:
  1. Add entry to levelBook.levels (array or object format)
  2. Manually verify solvability (with jump paths)
  3. Update ALL occurrences of "15" in code:
     - currentLevelBookLevel < 15  (completion check)
     - "of 15" in level indicator text (English and Afrikaans)
     - "All 15 levels" in completion message (English and Afrikaans)
     - levelBookLabel ('15 Challenges' / '15 Uitdagings')
     - levelSkipCheat prompt text
     - Header comment and documentation

================================================================================
14. TROUBLESHOOTING
================================================================================

Mouse does not move:
  Check moveForward() return value. Verify direction is 0/90/180/270.
  Check updateToken() called with correct parameters.

Last cheese does not trigger level complete:
  Ensure cheesePositions.length === 0 after eatCheese().
  Check that a 'boundary' jump before the Eat does NOT stop execution
  (boundary should break inner repeat loop, not return from executeCommands).

Level Book level does not load:
  Verify levelBook.levels[levelNum] exists. Check for typos in grid data.
  Ensure exactly one 'M' per level. Check browser console for errors.

Cat attacks wrong cat:
  Check data-cat-index on cat DOM elements matches catPositions[] indices.
  Verify triggerCatAttack() Euclidean distance calculation.

Screenshot incorrect:
  window.gridScreenshotBounds set 100ms after createGrid(). May need longer.
  Check html2canvas CDN is loading (Network tab in DevTools).

Language not switching:
  Verify all new UI element IDs handled in updateGameText().
  Check translations object has matching keys for en and af.

DEBUG:
  executeCommands() has extensive console.log() calls.
  Open DevTools Console (F12) to trace execution step by step.
  Key messages to watch:
    "=== EXECUTE COMMANDS STARTED ==="
    "Jump result: success/wall/cat/boundary"
    "Cheese remaining: N"
    "=== EXECUTION COMPLETED SUCCESSFULLY ==="

================================================================================
CONTACT & SUPPORT
================================================================================

Developer:    Bertie
Institution:  Tshwane University of Technology (TUT)
Department:   Information Technology
Purpose:      Educational tool for teaching sequential programming concepts

For bug reports please document: browser + version, steps to reproduce,
expected vs actual behaviour, console error messages (F12 > Console).

================================================================================
END OF DOCUMENTATION
================================================================================
-->

<!--
================================================================================
END OF GAME FILE - MAJOR VERSION 2.0
================================================================================

VERSION HISTORY:
----------------
Version 1.0 (January 2026) - Initial release:
  + Bilingual support (English/Afrikaans)
  + 5 random difficulty levels (3x4 to 6x9 grids)
  + Obstacles: cheese, traps, walls, cats
  + Command queue with repeat counts (1-9)
  + Hint toggle (L/R labels on mouse)
  + Smooth SVG animations and CSS transitions
  + BFS pathfinding validation for random levels
  + Auto-reset on failure, attempt-again functionality
  + Keyboard shortcuts (A/D/W/Space/E)

Version 2.0 (February 2026) - Level Book update:
  + Level Book mode: 15 handcrafted 5x5 challenge levels
  + All 15 levels manually verified solvable (including jump-only paths)
  + Level 7: forced initial direction (UP) for correct solution path
  + Animated flowing capes on splash screen and in-game mouse sprites
  + Return to Menu button (purple gradient) for mode navigation
  * Bug fix: mouse starting position resets correctly after menu return
  * Bug fix: jump() returns 'boundary' for out-of-bounds instead of false
             boundary jumps now silently skip instead of stopping execution
             (fixed "last cheese not collected" issue on Level 10 and similar)
  + Developer level-skip cheat (double-click level indicator bar)
  + Grid screenshot export via right-click (html2canvas CDN dependency)
  * Fixed instructions text: correctly states mouse CAN jump over traps
  * All "5 levels/challenges" references updated to "15" throughout

KNOWN LIMITATIONS:
  Requires modern browser (ES6+: Chrome 60+, Firefox 55+, Edge 79+)
  SVG SMIL animations may not render in very old browsers
  Screenshot feature requires internet access for html2canvas CDN
  Grid layout optimised for desktop/tablet (1024px+ recommended)
  No mobile/touch optimisation in Version 2.0 (planned for Phase 2/3)

FUTURE ENHANCEMENT IDEAS (Phase 3+):
  Progressive Web App (PWA) for mobile/offline installation
  Responsive layout for 7-inch phone screens (portrait + landscape)
  Sound effects and background music
  Level editor for teachers to create custom challenges
  Student progress tracking and save/load functionality
  Achievements and badge system
  Printable worksheet generator
  Additional languages (Zulu, Sotho, Xhosa)
  Animated intro sequence
  Timer and scoring system

================================================================================
-->
